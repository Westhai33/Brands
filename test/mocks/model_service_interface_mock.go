// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i Brands/internal/service.ModelServiceInterface -o model_service_interface_mock_test.go -n ModelServiceInterfaceMock -p mocks

import (
	"Brands/internal/dto"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ModelServiceInterfaceMock implements mm_service.ModelServiceInterface
type ModelServiceInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, model *dto.Model) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, model *dto.Model)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mModelServiceInterfaceMockCreate

	funcGetAll          func(ctx context.Context, filter string, sort string, order string) (ma1 []dto.Model, err error)
	funcGetAllOrigin    string
	inspectFuncGetAll   func(ctx context.Context, filter string, sort string, order string)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mModelServiceInterfaceMockGetAll

	funcGetByID          func(ctx context.Context, id int64) (mp1 *dto.Model, err error)
	funcGetByIDOrigin    string
	inspectFuncGetByID   func(ctx context.Context, id int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mModelServiceInterfaceMockGetByID

	funcRestore          func(ctx context.Context, id int64) (err error)
	funcRestoreOrigin    string
	inspectFuncRestore   func(ctx context.Context, id int64)
	afterRestoreCounter  uint64
	beforeRestoreCounter uint64
	RestoreMock          mModelServiceInterfaceMockRestore

	funcSoftDelete          func(ctx context.Context, id int64) (err error)
	funcSoftDeleteOrigin    string
	inspectFuncSoftDelete   func(ctx context.Context, id int64)
	afterSoftDeleteCounter  uint64
	beforeSoftDeleteCounter uint64
	SoftDeleteMock          mModelServiceInterfaceMockSoftDelete

	funcUpdate          func(ctx context.Context, model *dto.Model) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, model *dto.Model)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mModelServiceInterfaceMockUpdate
}

// NewModelServiceInterfaceMock returns a mock for mm_service.ModelServiceInterface
func NewModelServiceInterfaceMock(t minimock.Tester) *ModelServiceInterfaceMock {
	m := &ModelServiceInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mModelServiceInterfaceMockCreate{mock: m}
	m.CreateMock.callArgs = []*ModelServiceInterfaceMockCreateParams{}

	m.GetAllMock = mModelServiceInterfaceMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*ModelServiceInterfaceMockGetAllParams{}

	m.GetByIDMock = mModelServiceInterfaceMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*ModelServiceInterfaceMockGetByIDParams{}

	m.RestoreMock = mModelServiceInterfaceMockRestore{mock: m}
	m.RestoreMock.callArgs = []*ModelServiceInterfaceMockRestoreParams{}

	m.SoftDeleteMock = mModelServiceInterfaceMockSoftDelete{mock: m}
	m.SoftDeleteMock.callArgs = []*ModelServiceInterfaceMockSoftDeleteParams{}

	m.UpdateMock = mModelServiceInterfaceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*ModelServiceInterfaceMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mModelServiceInterfaceMockCreate struct {
	optional           bool
	mock               *ModelServiceInterfaceMock
	defaultExpectation *ModelServiceInterfaceMockCreateExpectation
	expectations       []*ModelServiceInterfaceMockCreateExpectation

	callArgs []*ModelServiceInterfaceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelServiceInterfaceMockCreateExpectation specifies expectation struct of the ModelServiceInterface.Create
type ModelServiceInterfaceMockCreateExpectation struct {
	mock               *ModelServiceInterfaceMock
	params             *ModelServiceInterfaceMockCreateParams
	paramPtrs          *ModelServiceInterfaceMockCreateParamPtrs
	expectationOrigins ModelServiceInterfaceMockCreateExpectationOrigins
	results            *ModelServiceInterfaceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// ModelServiceInterfaceMockCreateParams contains parameters of the ModelServiceInterface.Create
type ModelServiceInterfaceMockCreateParams struct {
	ctx   context.Context
	model *dto.Model
}

// ModelServiceInterfaceMockCreateParamPtrs contains pointers to parameters of the ModelServiceInterface.Create
type ModelServiceInterfaceMockCreateParamPtrs struct {
	ctx   *context.Context
	model **dto.Model
}

// ModelServiceInterfaceMockCreateResults contains results of the ModelServiceInterface.Create
type ModelServiceInterfaceMockCreateResults struct {
	i1  int64
	err error
}

// ModelServiceInterfaceMockCreateOrigins contains origins of expectations of the ModelServiceInterface.Create
type ModelServiceInterfaceMockCreateExpectationOrigins struct {
	origin      string
	originCtx   string
	originModel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mModelServiceInterfaceMockCreate) Optional() *mModelServiceInterfaceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for ModelServiceInterface.Create
func (mmCreate *mModelServiceInterfaceMockCreate) Expect(ctx context.Context, model *dto.Model) *mModelServiceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ModelServiceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ModelServiceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ModelServiceInterfaceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ModelServiceInterfaceMockCreateParams{ctx, model}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for ModelServiceInterface.Create
func (mmCreate *mModelServiceInterfaceMockCreate) ExpectCtxParam1(ctx context.Context) *mModelServiceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ModelServiceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ModelServiceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ModelServiceInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectModelParam2 sets up expected param model for ModelServiceInterface.Create
func (mmCreate *mModelServiceInterfaceMockCreate) ExpectModelParam2(model *dto.Model) *mModelServiceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ModelServiceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ModelServiceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ModelServiceInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.model = &model
	mmCreate.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ModelServiceInterface.Create
func (mmCreate *mModelServiceInterfaceMockCreate) Inspect(f func(ctx context.Context, model *dto.Model)) *mModelServiceInterfaceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ModelServiceInterfaceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ModelServiceInterface.Create
func (mmCreate *mModelServiceInterfaceMockCreate) Return(i1 int64, err error) *ModelServiceInterfaceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ModelServiceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ModelServiceInterfaceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ModelServiceInterfaceMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the ModelServiceInterface.Create method
func (mmCreate *mModelServiceInterfaceMockCreate) Set(f func(ctx context.Context, model *dto.Model) (i1 int64, err error)) *ModelServiceInterfaceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ModelServiceInterface.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ModelServiceInterface.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the ModelServiceInterface.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mModelServiceInterfaceMockCreate) When(ctx context.Context, model *dto.Model) *ModelServiceInterfaceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ModelServiceInterfaceMock.Create mock is already set by Set")
	}

	expectation := &ModelServiceInterfaceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &ModelServiceInterfaceMockCreateParams{ctx, model},
		expectationOrigins: ModelServiceInterfaceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ModelServiceInterface.Create return parameters for the expectation previously defined by the When method
func (e *ModelServiceInterfaceMockCreateExpectation) Then(i1 int64, err error) *ModelServiceInterfaceMock {
	e.results = &ModelServiceInterfaceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times ModelServiceInterface.Create should be invoked
func (mmCreate *mModelServiceInterfaceMockCreate) Times(n uint64) *mModelServiceInterfaceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ModelServiceInterfaceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mModelServiceInterfaceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_service.ModelServiceInterface
func (mmCreate *ModelServiceInterfaceMock) Create(ctx context.Context, model *dto.Model) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, model)
	}

	mm_params := ModelServiceInterfaceMockCreateParams{ctx, model}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ModelServiceInterfaceMockCreateParams{ctx, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ModelServiceInterfaceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmCreate.t.Errorf("ModelServiceInterfaceMock.Create got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ModelServiceInterfaceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ModelServiceInterfaceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, model)
	}
	mmCreate.t.Fatalf("Unexpected call to ModelServiceInterfaceMock.Create. %v %v", ctx, model)
	return
}

// CreateAfterCounter returns a count of finished ModelServiceInterfaceMock.Create invocations
func (mmCreate *ModelServiceInterfaceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ModelServiceInterfaceMock.Create invocations
func (mmCreate *ModelServiceInterfaceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ModelServiceInterfaceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mModelServiceInterfaceMockCreate) Calls() []*ModelServiceInterfaceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ModelServiceInterfaceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ModelServiceInterfaceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ModelServiceInterfaceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to ModelServiceInterfaceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelServiceInterfaceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mModelServiceInterfaceMockGetAll struct {
	optional           bool
	mock               *ModelServiceInterfaceMock
	defaultExpectation *ModelServiceInterfaceMockGetAllExpectation
	expectations       []*ModelServiceInterfaceMockGetAllExpectation

	callArgs []*ModelServiceInterfaceMockGetAllParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelServiceInterfaceMockGetAllExpectation specifies expectation struct of the ModelServiceInterface.GetAll
type ModelServiceInterfaceMockGetAllExpectation struct {
	mock               *ModelServiceInterfaceMock
	params             *ModelServiceInterfaceMockGetAllParams
	paramPtrs          *ModelServiceInterfaceMockGetAllParamPtrs
	expectationOrigins ModelServiceInterfaceMockGetAllExpectationOrigins
	results            *ModelServiceInterfaceMockGetAllResults
	returnOrigin       string
	Counter            uint64
}

// ModelServiceInterfaceMockGetAllParams contains parameters of the ModelServiceInterface.GetAll
type ModelServiceInterfaceMockGetAllParams struct {
	ctx    context.Context
	filter string
	sort   string
	order  string
}

// ModelServiceInterfaceMockGetAllParamPtrs contains pointers to parameters of the ModelServiceInterface.GetAll
type ModelServiceInterfaceMockGetAllParamPtrs struct {
	ctx    *context.Context
	filter *string
	sort   *string
	order  *string
}

// ModelServiceInterfaceMockGetAllResults contains results of the ModelServiceInterface.GetAll
type ModelServiceInterfaceMockGetAllResults struct {
	ma1 []dto.Model
	err error
}

// ModelServiceInterfaceMockGetAllOrigins contains origins of expectations of the ModelServiceInterface.GetAll
type ModelServiceInterfaceMockGetAllExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
	originSort   string
	originOrder  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAll *mModelServiceInterfaceMockGetAll) Optional() *mModelServiceInterfaceMockGetAll {
	mmGetAll.optional = true
	return mmGetAll
}

// Expect sets up expected params for ModelServiceInterface.GetAll
func (mmGetAll *mModelServiceInterfaceMockGetAll) Expect(ctx context.Context, filter string, sort string, order string) *mModelServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ModelServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.paramPtrs != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by ExpectParams functions")
	}

	mmGetAll.defaultExpectation.params = &ModelServiceInterfaceMockGetAllParams{ctx, filter, sort, order}
	mmGetAll.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// ExpectCtxParam1 sets up expected param ctx for ModelServiceInterface.GetAll
func (mmGetAll *mModelServiceInterfaceMockGetAll) ExpectCtxParam1(ctx context.Context) *mModelServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ModelServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAll.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAll
}

// ExpectFilterParam2 sets up expected param filter for ModelServiceInterface.GetAll
func (mmGetAll *mModelServiceInterfaceMockGetAll) ExpectFilterParam2(filter string) *mModelServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ModelServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.filter = &filter
	mmGetAll.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGetAll
}

// ExpectSortParam3 sets up expected param sort for ModelServiceInterface.GetAll
func (mmGetAll *mModelServiceInterfaceMockGetAll) ExpectSortParam3(sort string) *mModelServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ModelServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.sort = &sort
	mmGetAll.defaultExpectation.expectationOrigins.originSort = minimock.CallerInfo(1)

	return mmGetAll
}

// ExpectOrderParam4 sets up expected param order for ModelServiceInterface.GetAll
func (mmGetAll *mModelServiceInterfaceMockGetAll) ExpectOrderParam4(order string) *mModelServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ModelServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.order = &order
	mmGetAll.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the ModelServiceInterface.GetAll
func (mmGetAll *mModelServiceInterfaceMockGetAll) Inspect(f func(ctx context.Context, filter string, sort string, order string)) *mModelServiceInterfaceMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for ModelServiceInterfaceMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by ModelServiceInterface.GetAll
func (mmGetAll *mModelServiceInterfaceMockGetAll) Return(ma1 []dto.Model, err error) *ModelServiceInterfaceMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &ModelServiceInterfaceMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &ModelServiceInterfaceMockGetAllResults{ma1, err}
	mmGetAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// Set uses given function f to mock the ModelServiceInterface.GetAll method
func (mmGetAll *mModelServiceInterfaceMockGetAll) Set(f func(ctx context.Context, filter string, sort string, order string) (ma1 []dto.Model, err error)) *ModelServiceInterfaceMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the ModelServiceInterface.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the ModelServiceInterface.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	mmGetAll.mock.funcGetAllOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// When sets expectation for the ModelServiceInterface.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mModelServiceInterfaceMockGetAll) When(ctx context.Context, filter string, sort string, order string) *ModelServiceInterfaceMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("ModelServiceInterfaceMock.GetAll mock is already set by Set")
	}

	expectation := &ModelServiceInterfaceMockGetAllExpectation{
		mock:               mmGetAll.mock,
		params:             &ModelServiceInterfaceMockGetAllParams{ctx, filter, sort, order},
		expectationOrigins: ModelServiceInterfaceMockGetAllExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up ModelServiceInterface.GetAll return parameters for the expectation previously defined by the When method
func (e *ModelServiceInterfaceMockGetAllExpectation) Then(ma1 []dto.Model, err error) *ModelServiceInterfaceMock {
	e.results = &ModelServiceInterfaceMockGetAllResults{ma1, err}
	return e.mock
}

// Times sets number of times ModelServiceInterface.GetAll should be invoked
func (mmGetAll *mModelServiceInterfaceMockGetAll) Times(n uint64) *mModelServiceInterfaceMockGetAll {
	if n == 0 {
		mmGetAll.mock.t.Fatalf("Times of ModelServiceInterfaceMock.GetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAll.expectedInvocations, n)
	mmGetAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAll
}

func (mmGetAll *mModelServiceInterfaceMockGetAll) invocationsDone() bool {
	if len(mmGetAll.expectations) == 0 && mmGetAll.defaultExpectation == nil && mmGetAll.mock.funcGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAll.mock.afterGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAll implements mm_service.ModelServiceInterface
func (mmGetAll *ModelServiceInterfaceMock) GetAll(ctx context.Context, filter string, sort string, order string) (ma1 []dto.Model, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	mmGetAll.t.Helper()

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, filter, sort, order)
	}

	mm_params := ModelServiceInterfaceMockGetAllParams{ctx, filter, sort, order}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, &mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_want_ptrs := mmGetAll.GetAllMock.defaultExpectation.paramPtrs

		mm_got := ModelServiceInterfaceMockGetAllParams{ctx, filter, sort, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAll.t.Errorf("ModelServiceInterfaceMock.GetAll got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGetAll.t.Errorf("ModelServiceInterfaceMock.GetAll got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.sort != nil && !minimock.Equal(*mm_want_ptrs.sort, mm_got.sort) {
				mmGetAll.t.Errorf("ModelServiceInterfaceMock.GetAll got unexpected parameter sort, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originSort, *mm_want_ptrs.sort, mm_got.sort, minimock.Diff(*mm_want_ptrs.sort, mm_got.sort))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmGetAll.t.Errorf("ModelServiceInterfaceMock.GetAll got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("ModelServiceInterfaceMock.GetAll got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the ModelServiceInterfaceMock.GetAll")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, filter, sort, order)
	}
	mmGetAll.t.Fatalf("Unexpected call to ModelServiceInterfaceMock.GetAll. %v %v %v %v", ctx, filter, sort, order)
	return
}

// GetAllAfterCounter returns a count of finished ModelServiceInterfaceMock.GetAll invocations
func (mmGetAll *ModelServiceInterfaceMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of ModelServiceInterfaceMock.GetAll invocations
func (mmGetAll *ModelServiceInterfaceMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to ModelServiceInterfaceMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mModelServiceInterfaceMockGetAll) Calls() []*ModelServiceInterfaceMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*ModelServiceInterfaceMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *ModelServiceInterfaceMock) MinimockGetAllDone() bool {
	if m.GetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllMock.invocationsDone()
}

// MinimockGetAllInspect logs each unmet expectation
func (m *ModelServiceInterfaceMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.GetAll at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllCounter := mm_atomic.LoadUint64(&m.afterGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && afterGetAllCounter < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.GetAll at\n%s", m.GetAllMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.GetAll at\n%s with params: %#v", m.GetAllMock.defaultExpectation.expectationOrigins.origin, *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && afterGetAllCounter < 1 {
		m.t.Errorf("Expected call to ModelServiceInterfaceMock.GetAll at\n%s", m.funcGetAllOrigin)
	}

	if !m.GetAllMock.invocationsDone() && afterGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelServiceInterfaceMock.GetAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllMock.expectedInvocations), m.GetAllMock.expectedInvocationsOrigin, afterGetAllCounter)
	}
}

type mModelServiceInterfaceMockGetByID struct {
	optional           bool
	mock               *ModelServiceInterfaceMock
	defaultExpectation *ModelServiceInterfaceMockGetByIDExpectation
	expectations       []*ModelServiceInterfaceMockGetByIDExpectation

	callArgs []*ModelServiceInterfaceMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelServiceInterfaceMockGetByIDExpectation specifies expectation struct of the ModelServiceInterface.GetByID
type ModelServiceInterfaceMockGetByIDExpectation struct {
	mock               *ModelServiceInterfaceMock
	params             *ModelServiceInterfaceMockGetByIDParams
	paramPtrs          *ModelServiceInterfaceMockGetByIDParamPtrs
	expectationOrigins ModelServiceInterfaceMockGetByIDExpectationOrigins
	results            *ModelServiceInterfaceMockGetByIDResults
	returnOrigin       string
	Counter            uint64
}

// ModelServiceInterfaceMockGetByIDParams contains parameters of the ModelServiceInterface.GetByID
type ModelServiceInterfaceMockGetByIDParams struct {
	ctx context.Context
	id  int64
}

// ModelServiceInterfaceMockGetByIDParamPtrs contains pointers to parameters of the ModelServiceInterface.GetByID
type ModelServiceInterfaceMockGetByIDParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ModelServiceInterfaceMockGetByIDResults contains results of the ModelServiceInterface.GetByID
type ModelServiceInterfaceMockGetByIDResults struct {
	mp1 *dto.Model
	err error
}

// ModelServiceInterfaceMockGetByIDOrigins contains origins of expectations of the ModelServiceInterface.GetByID
type ModelServiceInterfaceMockGetByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mModelServiceInterfaceMockGetByID) Optional() *mModelServiceInterfaceMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for ModelServiceInterface.GetByID
func (mmGetByID *mModelServiceInterfaceMockGetByID) Expect(ctx context.Context, id int64) *mModelServiceInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("ModelServiceInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &ModelServiceInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("ModelServiceInterfaceMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &ModelServiceInterfaceMockGetByIDParams{ctx, id}
	mmGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for ModelServiceInterface.GetByID
func (mmGetByID *mModelServiceInterfaceMockGetByID) ExpectCtxParam1(ctx context.Context) *mModelServiceInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("ModelServiceInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &ModelServiceInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("ModelServiceInterfaceMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByID
}

// ExpectIdParam2 sets up expected param id for ModelServiceInterface.GetByID
func (mmGetByID *mModelServiceInterfaceMockGetByID) ExpectIdParam2(id int64) *mModelServiceInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("ModelServiceInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &ModelServiceInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("ModelServiceInterfaceMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.id = &id
	mmGetByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the ModelServiceInterface.GetByID
func (mmGetByID *mModelServiceInterfaceMockGetByID) Inspect(f func(ctx context.Context, id int64)) *mModelServiceInterfaceMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for ModelServiceInterfaceMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by ModelServiceInterface.GetByID
func (mmGetByID *mModelServiceInterfaceMockGetByID) Return(mp1 *dto.Model, err error) *ModelServiceInterfaceMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("ModelServiceInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &ModelServiceInterfaceMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &ModelServiceInterfaceMockGetByIDResults{mp1, err}
	mmGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// Set uses given function f to mock the ModelServiceInterface.GetByID method
func (mmGetByID *mModelServiceInterfaceMockGetByID) Set(f func(ctx context.Context, id int64) (mp1 *dto.Model, err error)) *ModelServiceInterfaceMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the ModelServiceInterface.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the ModelServiceInterface.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	mmGetByID.mock.funcGetByIDOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// When sets expectation for the ModelServiceInterface.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mModelServiceInterfaceMockGetByID) When(ctx context.Context, id int64) *ModelServiceInterfaceMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("ModelServiceInterfaceMock.GetByID mock is already set by Set")
	}

	expectation := &ModelServiceInterfaceMockGetByIDExpectation{
		mock:               mmGetByID.mock,
		params:             &ModelServiceInterfaceMockGetByIDParams{ctx, id},
		expectationOrigins: ModelServiceInterfaceMockGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up ModelServiceInterface.GetByID return parameters for the expectation previously defined by the When method
func (e *ModelServiceInterfaceMockGetByIDExpectation) Then(mp1 *dto.Model, err error) *ModelServiceInterfaceMock {
	e.results = &ModelServiceInterfaceMockGetByIDResults{mp1, err}
	return e.mock
}

// Times sets number of times ModelServiceInterface.GetByID should be invoked
func (mmGetByID *mModelServiceInterfaceMockGetByID) Times(n uint64) *mModelServiceInterfaceMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of ModelServiceInterfaceMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	mmGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByID
}

func (mmGetByID *mModelServiceInterfaceMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements mm_service.ModelServiceInterface
func (mmGetByID *ModelServiceInterfaceMock) GetByID(ctx context.Context, id int64) (mp1 *dto.Model, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	mmGetByID.t.Helper()

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, id)
	}

	mm_params := ModelServiceInterfaceMockGetByIDParams{ctx, id}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := ModelServiceInterfaceMockGetByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("ModelServiceInterfaceMock.GetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetByID.t.Errorf("ModelServiceInterfaceMock.GetByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("ModelServiceInterfaceMock.GetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the ModelServiceInterfaceMock.GetByID")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, id)
	}
	mmGetByID.t.Fatalf("Unexpected call to ModelServiceInterfaceMock.GetByID. %v %v", ctx, id)
	return
}

// GetByIDAfterCounter returns a count of finished ModelServiceInterfaceMock.GetByID invocations
func (mmGetByID *ModelServiceInterfaceMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of ModelServiceInterfaceMock.GetByID invocations
func (mmGetByID *ModelServiceInterfaceMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to ModelServiceInterfaceMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mModelServiceInterfaceMockGetByID) Calls() []*ModelServiceInterfaceMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*ModelServiceInterfaceMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *ModelServiceInterfaceMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *ModelServiceInterfaceMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.GetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.GetByID at\n%s", m.GetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.GetByID at\n%s with params: %#v", m.GetByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Errorf("Expected call to ModelServiceInterfaceMock.GetByID at\n%s", m.funcGetByIDOrigin)
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelServiceInterfaceMock.GetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), m.GetByIDMock.expectedInvocationsOrigin, afterGetByIDCounter)
	}
}

type mModelServiceInterfaceMockRestore struct {
	optional           bool
	mock               *ModelServiceInterfaceMock
	defaultExpectation *ModelServiceInterfaceMockRestoreExpectation
	expectations       []*ModelServiceInterfaceMockRestoreExpectation

	callArgs []*ModelServiceInterfaceMockRestoreParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelServiceInterfaceMockRestoreExpectation specifies expectation struct of the ModelServiceInterface.Restore
type ModelServiceInterfaceMockRestoreExpectation struct {
	mock               *ModelServiceInterfaceMock
	params             *ModelServiceInterfaceMockRestoreParams
	paramPtrs          *ModelServiceInterfaceMockRestoreParamPtrs
	expectationOrigins ModelServiceInterfaceMockRestoreExpectationOrigins
	results            *ModelServiceInterfaceMockRestoreResults
	returnOrigin       string
	Counter            uint64
}

// ModelServiceInterfaceMockRestoreParams contains parameters of the ModelServiceInterface.Restore
type ModelServiceInterfaceMockRestoreParams struct {
	ctx context.Context
	id  int64
}

// ModelServiceInterfaceMockRestoreParamPtrs contains pointers to parameters of the ModelServiceInterface.Restore
type ModelServiceInterfaceMockRestoreParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ModelServiceInterfaceMockRestoreResults contains results of the ModelServiceInterface.Restore
type ModelServiceInterfaceMockRestoreResults struct {
	err error
}

// ModelServiceInterfaceMockRestoreOrigins contains origins of expectations of the ModelServiceInterface.Restore
type ModelServiceInterfaceMockRestoreExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRestore *mModelServiceInterfaceMockRestore) Optional() *mModelServiceInterfaceMockRestore {
	mmRestore.optional = true
	return mmRestore
}

// Expect sets up expected params for ModelServiceInterface.Restore
func (mmRestore *mModelServiceInterfaceMockRestore) Expect(ctx context.Context, id int64) *mModelServiceInterfaceMockRestore {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("ModelServiceInterfaceMock.Restore mock is already set by Set")
	}

	if mmRestore.defaultExpectation == nil {
		mmRestore.defaultExpectation = &ModelServiceInterfaceMockRestoreExpectation{}
	}

	if mmRestore.defaultExpectation.paramPtrs != nil {
		mmRestore.mock.t.Fatalf("ModelServiceInterfaceMock.Restore mock is already set by ExpectParams functions")
	}

	mmRestore.defaultExpectation.params = &ModelServiceInterfaceMockRestoreParams{ctx, id}
	mmRestore.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRestore.expectations {
		if minimock.Equal(e.params, mmRestore.defaultExpectation.params) {
			mmRestore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRestore.defaultExpectation.params)
		}
	}

	return mmRestore
}

// ExpectCtxParam1 sets up expected param ctx for ModelServiceInterface.Restore
func (mmRestore *mModelServiceInterfaceMockRestore) ExpectCtxParam1(ctx context.Context) *mModelServiceInterfaceMockRestore {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("ModelServiceInterfaceMock.Restore mock is already set by Set")
	}

	if mmRestore.defaultExpectation == nil {
		mmRestore.defaultExpectation = &ModelServiceInterfaceMockRestoreExpectation{}
	}

	if mmRestore.defaultExpectation.params != nil {
		mmRestore.mock.t.Fatalf("ModelServiceInterfaceMock.Restore mock is already set by Expect")
	}

	if mmRestore.defaultExpectation.paramPtrs == nil {
		mmRestore.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockRestoreParamPtrs{}
	}
	mmRestore.defaultExpectation.paramPtrs.ctx = &ctx
	mmRestore.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRestore
}

// ExpectIdParam2 sets up expected param id for ModelServiceInterface.Restore
func (mmRestore *mModelServiceInterfaceMockRestore) ExpectIdParam2(id int64) *mModelServiceInterfaceMockRestore {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("ModelServiceInterfaceMock.Restore mock is already set by Set")
	}

	if mmRestore.defaultExpectation == nil {
		mmRestore.defaultExpectation = &ModelServiceInterfaceMockRestoreExpectation{}
	}

	if mmRestore.defaultExpectation.params != nil {
		mmRestore.mock.t.Fatalf("ModelServiceInterfaceMock.Restore mock is already set by Expect")
	}

	if mmRestore.defaultExpectation.paramPtrs == nil {
		mmRestore.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockRestoreParamPtrs{}
	}
	mmRestore.defaultExpectation.paramPtrs.id = &id
	mmRestore.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmRestore
}

// Inspect accepts an inspector function that has same arguments as the ModelServiceInterface.Restore
func (mmRestore *mModelServiceInterfaceMockRestore) Inspect(f func(ctx context.Context, id int64)) *mModelServiceInterfaceMockRestore {
	if mmRestore.mock.inspectFuncRestore != nil {
		mmRestore.mock.t.Fatalf("Inspect function is already set for ModelServiceInterfaceMock.Restore")
	}

	mmRestore.mock.inspectFuncRestore = f

	return mmRestore
}

// Return sets up results that will be returned by ModelServiceInterface.Restore
func (mmRestore *mModelServiceInterfaceMockRestore) Return(err error) *ModelServiceInterfaceMock {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("ModelServiceInterfaceMock.Restore mock is already set by Set")
	}

	if mmRestore.defaultExpectation == nil {
		mmRestore.defaultExpectation = &ModelServiceInterfaceMockRestoreExpectation{mock: mmRestore.mock}
	}
	mmRestore.defaultExpectation.results = &ModelServiceInterfaceMockRestoreResults{err}
	mmRestore.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRestore.mock
}

// Set uses given function f to mock the ModelServiceInterface.Restore method
func (mmRestore *mModelServiceInterfaceMockRestore) Set(f func(ctx context.Context, id int64) (err error)) *ModelServiceInterfaceMock {
	if mmRestore.defaultExpectation != nil {
		mmRestore.mock.t.Fatalf("Default expectation is already set for the ModelServiceInterface.Restore method")
	}

	if len(mmRestore.expectations) > 0 {
		mmRestore.mock.t.Fatalf("Some expectations are already set for the ModelServiceInterface.Restore method")
	}

	mmRestore.mock.funcRestore = f
	mmRestore.mock.funcRestoreOrigin = minimock.CallerInfo(1)
	return mmRestore.mock
}

// When sets expectation for the ModelServiceInterface.Restore which will trigger the result defined by the following
// Then helper
func (mmRestore *mModelServiceInterfaceMockRestore) When(ctx context.Context, id int64) *ModelServiceInterfaceMockRestoreExpectation {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("ModelServiceInterfaceMock.Restore mock is already set by Set")
	}

	expectation := &ModelServiceInterfaceMockRestoreExpectation{
		mock:               mmRestore.mock,
		params:             &ModelServiceInterfaceMockRestoreParams{ctx, id},
		expectationOrigins: ModelServiceInterfaceMockRestoreExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRestore.expectations = append(mmRestore.expectations, expectation)
	return expectation
}

// Then sets up ModelServiceInterface.Restore return parameters for the expectation previously defined by the When method
func (e *ModelServiceInterfaceMockRestoreExpectation) Then(err error) *ModelServiceInterfaceMock {
	e.results = &ModelServiceInterfaceMockRestoreResults{err}
	return e.mock
}

// Times sets number of times ModelServiceInterface.Restore should be invoked
func (mmRestore *mModelServiceInterfaceMockRestore) Times(n uint64) *mModelServiceInterfaceMockRestore {
	if n == 0 {
		mmRestore.mock.t.Fatalf("Times of ModelServiceInterfaceMock.Restore mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRestore.expectedInvocations, n)
	mmRestore.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRestore
}

func (mmRestore *mModelServiceInterfaceMockRestore) invocationsDone() bool {
	if len(mmRestore.expectations) == 0 && mmRestore.defaultExpectation == nil && mmRestore.mock.funcRestore == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRestore.mock.afterRestoreCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRestore.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Restore implements mm_service.ModelServiceInterface
func (mmRestore *ModelServiceInterfaceMock) Restore(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmRestore.beforeRestoreCounter, 1)
	defer mm_atomic.AddUint64(&mmRestore.afterRestoreCounter, 1)

	mmRestore.t.Helper()

	if mmRestore.inspectFuncRestore != nil {
		mmRestore.inspectFuncRestore(ctx, id)
	}

	mm_params := ModelServiceInterfaceMockRestoreParams{ctx, id}

	// Record call args
	mmRestore.RestoreMock.mutex.Lock()
	mmRestore.RestoreMock.callArgs = append(mmRestore.RestoreMock.callArgs, &mm_params)
	mmRestore.RestoreMock.mutex.Unlock()

	for _, e := range mmRestore.RestoreMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRestore.RestoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRestore.RestoreMock.defaultExpectation.Counter, 1)
		mm_want := mmRestore.RestoreMock.defaultExpectation.params
		mm_want_ptrs := mmRestore.RestoreMock.defaultExpectation.paramPtrs

		mm_got := ModelServiceInterfaceMockRestoreParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRestore.t.Errorf("ModelServiceInterfaceMock.Restore got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRestore.RestoreMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmRestore.t.Errorf("ModelServiceInterfaceMock.Restore got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRestore.RestoreMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRestore.t.Errorf("ModelServiceInterfaceMock.Restore got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRestore.RestoreMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRestore.RestoreMock.defaultExpectation.results
		if mm_results == nil {
			mmRestore.t.Fatal("No results are set for the ModelServiceInterfaceMock.Restore")
		}
		return (*mm_results).err
	}
	if mmRestore.funcRestore != nil {
		return mmRestore.funcRestore(ctx, id)
	}
	mmRestore.t.Fatalf("Unexpected call to ModelServiceInterfaceMock.Restore. %v %v", ctx, id)
	return
}

// RestoreAfterCounter returns a count of finished ModelServiceInterfaceMock.Restore invocations
func (mmRestore *ModelServiceInterfaceMock) RestoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestore.afterRestoreCounter)
}

// RestoreBeforeCounter returns a count of ModelServiceInterfaceMock.Restore invocations
func (mmRestore *ModelServiceInterfaceMock) RestoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestore.beforeRestoreCounter)
}

// Calls returns a list of arguments used in each call to ModelServiceInterfaceMock.Restore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRestore *mModelServiceInterfaceMockRestore) Calls() []*ModelServiceInterfaceMockRestoreParams {
	mmRestore.mutex.RLock()

	argCopy := make([]*ModelServiceInterfaceMockRestoreParams, len(mmRestore.callArgs))
	copy(argCopy, mmRestore.callArgs)

	mmRestore.mutex.RUnlock()

	return argCopy
}

// MinimockRestoreDone returns true if the count of the Restore invocations corresponds
// the number of defined expectations
func (m *ModelServiceInterfaceMock) MinimockRestoreDone() bool {
	if m.RestoreMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RestoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RestoreMock.invocationsDone()
}

// MinimockRestoreInspect logs each unmet expectation
func (m *ModelServiceInterfaceMock) MinimockRestoreInspect() {
	for _, e := range m.RestoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Restore at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRestoreCounter := mm_atomic.LoadUint64(&m.afterRestoreCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RestoreMock.defaultExpectation != nil && afterRestoreCounter < 1 {
		if m.RestoreMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Restore at\n%s", m.RestoreMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Restore at\n%s with params: %#v", m.RestoreMock.defaultExpectation.expectationOrigins.origin, *m.RestoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRestore != nil && afterRestoreCounter < 1 {
		m.t.Errorf("Expected call to ModelServiceInterfaceMock.Restore at\n%s", m.funcRestoreOrigin)
	}

	if !m.RestoreMock.invocationsDone() && afterRestoreCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelServiceInterfaceMock.Restore at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RestoreMock.expectedInvocations), m.RestoreMock.expectedInvocationsOrigin, afterRestoreCounter)
	}
}

type mModelServiceInterfaceMockSoftDelete struct {
	optional           bool
	mock               *ModelServiceInterfaceMock
	defaultExpectation *ModelServiceInterfaceMockSoftDeleteExpectation
	expectations       []*ModelServiceInterfaceMockSoftDeleteExpectation

	callArgs []*ModelServiceInterfaceMockSoftDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelServiceInterfaceMockSoftDeleteExpectation specifies expectation struct of the ModelServiceInterface.SoftDelete
type ModelServiceInterfaceMockSoftDeleteExpectation struct {
	mock               *ModelServiceInterfaceMock
	params             *ModelServiceInterfaceMockSoftDeleteParams
	paramPtrs          *ModelServiceInterfaceMockSoftDeleteParamPtrs
	expectationOrigins ModelServiceInterfaceMockSoftDeleteExpectationOrigins
	results            *ModelServiceInterfaceMockSoftDeleteResults
	returnOrigin       string
	Counter            uint64
}

// ModelServiceInterfaceMockSoftDeleteParams contains parameters of the ModelServiceInterface.SoftDelete
type ModelServiceInterfaceMockSoftDeleteParams struct {
	ctx context.Context
	id  int64
}

// ModelServiceInterfaceMockSoftDeleteParamPtrs contains pointers to parameters of the ModelServiceInterface.SoftDelete
type ModelServiceInterfaceMockSoftDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ModelServiceInterfaceMockSoftDeleteResults contains results of the ModelServiceInterface.SoftDelete
type ModelServiceInterfaceMockSoftDeleteResults struct {
	err error
}

// ModelServiceInterfaceMockSoftDeleteOrigins contains origins of expectations of the ModelServiceInterface.SoftDelete
type ModelServiceInterfaceMockSoftDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) Optional() *mModelServiceInterfaceMockSoftDelete {
	mmSoftDelete.optional = true
	return mmSoftDelete
}

// Expect sets up expected params for ModelServiceInterface.SoftDelete
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) Expect(ctx context.Context, id int64) *mModelServiceInterfaceMockSoftDelete {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("ModelServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &ModelServiceInterfaceMockSoftDeleteExpectation{}
	}

	if mmSoftDelete.defaultExpectation.paramPtrs != nil {
		mmSoftDelete.mock.t.Fatalf("ModelServiceInterfaceMock.SoftDelete mock is already set by ExpectParams functions")
	}

	mmSoftDelete.defaultExpectation.params = &ModelServiceInterfaceMockSoftDeleteParams{ctx, id}
	mmSoftDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSoftDelete.expectations {
		if minimock.Equal(e.params, mmSoftDelete.defaultExpectation.params) {
			mmSoftDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSoftDelete.defaultExpectation.params)
		}
	}

	return mmSoftDelete
}

// ExpectCtxParam1 sets up expected param ctx for ModelServiceInterface.SoftDelete
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) ExpectCtxParam1(ctx context.Context) *mModelServiceInterfaceMockSoftDelete {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("ModelServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &ModelServiceInterfaceMockSoftDeleteExpectation{}
	}

	if mmSoftDelete.defaultExpectation.params != nil {
		mmSoftDelete.mock.t.Fatalf("ModelServiceInterfaceMock.SoftDelete mock is already set by Expect")
	}

	if mmSoftDelete.defaultExpectation.paramPtrs == nil {
		mmSoftDelete.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockSoftDeleteParamPtrs{}
	}
	mmSoftDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmSoftDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSoftDelete
}

// ExpectIdParam2 sets up expected param id for ModelServiceInterface.SoftDelete
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) ExpectIdParam2(id int64) *mModelServiceInterfaceMockSoftDelete {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("ModelServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &ModelServiceInterfaceMockSoftDeleteExpectation{}
	}

	if mmSoftDelete.defaultExpectation.params != nil {
		mmSoftDelete.mock.t.Fatalf("ModelServiceInterfaceMock.SoftDelete mock is already set by Expect")
	}

	if mmSoftDelete.defaultExpectation.paramPtrs == nil {
		mmSoftDelete.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockSoftDeleteParamPtrs{}
	}
	mmSoftDelete.defaultExpectation.paramPtrs.id = &id
	mmSoftDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmSoftDelete
}

// Inspect accepts an inspector function that has same arguments as the ModelServiceInterface.SoftDelete
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) Inspect(f func(ctx context.Context, id int64)) *mModelServiceInterfaceMockSoftDelete {
	if mmSoftDelete.mock.inspectFuncSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("Inspect function is already set for ModelServiceInterfaceMock.SoftDelete")
	}

	mmSoftDelete.mock.inspectFuncSoftDelete = f

	return mmSoftDelete
}

// Return sets up results that will be returned by ModelServiceInterface.SoftDelete
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) Return(err error) *ModelServiceInterfaceMock {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("ModelServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &ModelServiceInterfaceMockSoftDeleteExpectation{mock: mmSoftDelete.mock}
	}
	mmSoftDelete.defaultExpectation.results = &ModelServiceInterfaceMockSoftDeleteResults{err}
	mmSoftDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSoftDelete.mock
}

// Set uses given function f to mock the ModelServiceInterface.SoftDelete method
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) Set(f func(ctx context.Context, id int64) (err error)) *ModelServiceInterfaceMock {
	if mmSoftDelete.defaultExpectation != nil {
		mmSoftDelete.mock.t.Fatalf("Default expectation is already set for the ModelServiceInterface.SoftDelete method")
	}

	if len(mmSoftDelete.expectations) > 0 {
		mmSoftDelete.mock.t.Fatalf("Some expectations are already set for the ModelServiceInterface.SoftDelete method")
	}

	mmSoftDelete.mock.funcSoftDelete = f
	mmSoftDelete.mock.funcSoftDeleteOrigin = minimock.CallerInfo(1)
	return mmSoftDelete.mock
}

// When sets expectation for the ModelServiceInterface.SoftDelete which will trigger the result defined by the following
// Then helper
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) When(ctx context.Context, id int64) *ModelServiceInterfaceMockSoftDeleteExpectation {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("ModelServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	expectation := &ModelServiceInterfaceMockSoftDeleteExpectation{
		mock:               mmSoftDelete.mock,
		params:             &ModelServiceInterfaceMockSoftDeleteParams{ctx, id},
		expectationOrigins: ModelServiceInterfaceMockSoftDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSoftDelete.expectations = append(mmSoftDelete.expectations, expectation)
	return expectation
}

// Then sets up ModelServiceInterface.SoftDelete return parameters for the expectation previously defined by the When method
func (e *ModelServiceInterfaceMockSoftDeleteExpectation) Then(err error) *ModelServiceInterfaceMock {
	e.results = &ModelServiceInterfaceMockSoftDeleteResults{err}
	return e.mock
}

// Times sets number of times ModelServiceInterface.SoftDelete should be invoked
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) Times(n uint64) *mModelServiceInterfaceMockSoftDelete {
	if n == 0 {
		mmSoftDelete.mock.t.Fatalf("Times of ModelServiceInterfaceMock.SoftDelete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSoftDelete.expectedInvocations, n)
	mmSoftDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSoftDelete
}

func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) invocationsDone() bool {
	if len(mmSoftDelete.expectations) == 0 && mmSoftDelete.defaultExpectation == nil && mmSoftDelete.mock.funcSoftDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSoftDelete.mock.afterSoftDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSoftDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SoftDelete implements mm_service.ModelServiceInterface
func (mmSoftDelete *ModelServiceInterfaceMock) SoftDelete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmSoftDelete.beforeSoftDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmSoftDelete.afterSoftDeleteCounter, 1)

	mmSoftDelete.t.Helper()

	if mmSoftDelete.inspectFuncSoftDelete != nil {
		mmSoftDelete.inspectFuncSoftDelete(ctx, id)
	}

	mm_params := ModelServiceInterfaceMockSoftDeleteParams{ctx, id}

	// Record call args
	mmSoftDelete.SoftDeleteMock.mutex.Lock()
	mmSoftDelete.SoftDeleteMock.callArgs = append(mmSoftDelete.SoftDeleteMock.callArgs, &mm_params)
	mmSoftDelete.SoftDeleteMock.mutex.Unlock()

	for _, e := range mmSoftDelete.SoftDeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSoftDelete.SoftDeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSoftDelete.SoftDeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmSoftDelete.SoftDeleteMock.defaultExpectation.params
		mm_want_ptrs := mmSoftDelete.SoftDeleteMock.defaultExpectation.paramPtrs

		mm_got := ModelServiceInterfaceMockSoftDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSoftDelete.t.Errorf("ModelServiceInterfaceMock.SoftDelete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSoftDelete.SoftDeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmSoftDelete.t.Errorf("ModelServiceInterfaceMock.SoftDelete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSoftDelete.SoftDeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSoftDelete.t.Errorf("ModelServiceInterfaceMock.SoftDelete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSoftDelete.SoftDeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSoftDelete.SoftDeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmSoftDelete.t.Fatal("No results are set for the ModelServiceInterfaceMock.SoftDelete")
		}
		return (*mm_results).err
	}
	if mmSoftDelete.funcSoftDelete != nil {
		return mmSoftDelete.funcSoftDelete(ctx, id)
	}
	mmSoftDelete.t.Fatalf("Unexpected call to ModelServiceInterfaceMock.SoftDelete. %v %v", ctx, id)
	return
}

// SoftDeleteAfterCounter returns a count of finished ModelServiceInterfaceMock.SoftDelete invocations
func (mmSoftDelete *ModelServiceInterfaceMock) SoftDeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSoftDelete.afterSoftDeleteCounter)
}

// SoftDeleteBeforeCounter returns a count of ModelServiceInterfaceMock.SoftDelete invocations
func (mmSoftDelete *ModelServiceInterfaceMock) SoftDeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSoftDelete.beforeSoftDeleteCounter)
}

// Calls returns a list of arguments used in each call to ModelServiceInterfaceMock.SoftDelete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSoftDelete *mModelServiceInterfaceMockSoftDelete) Calls() []*ModelServiceInterfaceMockSoftDeleteParams {
	mmSoftDelete.mutex.RLock()

	argCopy := make([]*ModelServiceInterfaceMockSoftDeleteParams, len(mmSoftDelete.callArgs))
	copy(argCopy, mmSoftDelete.callArgs)

	mmSoftDelete.mutex.RUnlock()

	return argCopy
}

// MinimockSoftDeleteDone returns true if the count of the SoftDelete invocations corresponds
// the number of defined expectations
func (m *ModelServiceInterfaceMock) MinimockSoftDeleteDone() bool {
	if m.SoftDeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SoftDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SoftDeleteMock.invocationsDone()
}

// MinimockSoftDeleteInspect logs each unmet expectation
func (m *ModelServiceInterfaceMock) MinimockSoftDeleteInspect() {
	for _, e := range m.SoftDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.SoftDelete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSoftDeleteCounter := mm_atomic.LoadUint64(&m.afterSoftDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SoftDeleteMock.defaultExpectation != nil && afterSoftDeleteCounter < 1 {
		if m.SoftDeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.SoftDelete at\n%s", m.SoftDeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.SoftDelete at\n%s with params: %#v", m.SoftDeleteMock.defaultExpectation.expectationOrigins.origin, *m.SoftDeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSoftDelete != nil && afterSoftDeleteCounter < 1 {
		m.t.Errorf("Expected call to ModelServiceInterfaceMock.SoftDelete at\n%s", m.funcSoftDeleteOrigin)
	}

	if !m.SoftDeleteMock.invocationsDone() && afterSoftDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelServiceInterfaceMock.SoftDelete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SoftDeleteMock.expectedInvocations), m.SoftDeleteMock.expectedInvocationsOrigin, afterSoftDeleteCounter)
	}
}

type mModelServiceInterfaceMockUpdate struct {
	optional           bool
	mock               *ModelServiceInterfaceMock
	defaultExpectation *ModelServiceInterfaceMockUpdateExpectation
	expectations       []*ModelServiceInterfaceMockUpdateExpectation

	callArgs []*ModelServiceInterfaceMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelServiceInterfaceMockUpdateExpectation specifies expectation struct of the ModelServiceInterface.Update
type ModelServiceInterfaceMockUpdateExpectation struct {
	mock               *ModelServiceInterfaceMock
	params             *ModelServiceInterfaceMockUpdateParams
	paramPtrs          *ModelServiceInterfaceMockUpdateParamPtrs
	expectationOrigins ModelServiceInterfaceMockUpdateExpectationOrigins
	results            *ModelServiceInterfaceMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// ModelServiceInterfaceMockUpdateParams contains parameters of the ModelServiceInterface.Update
type ModelServiceInterfaceMockUpdateParams struct {
	ctx   context.Context
	model *dto.Model
}

// ModelServiceInterfaceMockUpdateParamPtrs contains pointers to parameters of the ModelServiceInterface.Update
type ModelServiceInterfaceMockUpdateParamPtrs struct {
	ctx   *context.Context
	model **dto.Model
}

// ModelServiceInterfaceMockUpdateResults contains results of the ModelServiceInterface.Update
type ModelServiceInterfaceMockUpdateResults struct {
	err error
}

// ModelServiceInterfaceMockUpdateOrigins contains origins of expectations of the ModelServiceInterface.Update
type ModelServiceInterfaceMockUpdateExpectationOrigins struct {
	origin      string
	originCtx   string
	originModel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mModelServiceInterfaceMockUpdate) Optional() *mModelServiceInterfaceMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for ModelServiceInterface.Update
func (mmUpdate *mModelServiceInterfaceMockUpdate) Expect(ctx context.Context, model *dto.Model) *mModelServiceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ModelServiceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ModelServiceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("ModelServiceInterfaceMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &ModelServiceInterfaceMockUpdateParams{ctx, model}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for ModelServiceInterface.Update
func (mmUpdate *mModelServiceInterfaceMockUpdate) ExpectCtxParam1(ctx context.Context) *mModelServiceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ModelServiceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ModelServiceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("ModelServiceInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectModelParam2 sets up expected param model for ModelServiceInterface.Update
func (mmUpdate *mModelServiceInterfaceMockUpdate) ExpectModelParam2(model *dto.Model) *mModelServiceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ModelServiceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ModelServiceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("ModelServiceInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &ModelServiceInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.model = &model
	mmUpdate.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the ModelServiceInterface.Update
func (mmUpdate *mModelServiceInterfaceMockUpdate) Inspect(f func(ctx context.Context, model *dto.Model)) *mModelServiceInterfaceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for ModelServiceInterfaceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by ModelServiceInterface.Update
func (mmUpdate *mModelServiceInterfaceMockUpdate) Return(err error) *ModelServiceInterfaceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ModelServiceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &ModelServiceInterfaceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &ModelServiceInterfaceMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the ModelServiceInterface.Update method
func (mmUpdate *mModelServiceInterfaceMockUpdate) Set(f func(ctx context.Context, model *dto.Model) (err error)) *ModelServiceInterfaceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the ModelServiceInterface.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the ModelServiceInterface.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the ModelServiceInterface.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mModelServiceInterfaceMockUpdate) When(ctx context.Context, model *dto.Model) *ModelServiceInterfaceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("ModelServiceInterfaceMock.Update mock is already set by Set")
	}

	expectation := &ModelServiceInterfaceMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &ModelServiceInterfaceMockUpdateParams{ctx, model},
		expectationOrigins: ModelServiceInterfaceMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up ModelServiceInterface.Update return parameters for the expectation previously defined by the When method
func (e *ModelServiceInterfaceMockUpdateExpectation) Then(err error) *ModelServiceInterfaceMock {
	e.results = &ModelServiceInterfaceMockUpdateResults{err}
	return e.mock
}

// Times sets number of times ModelServiceInterface.Update should be invoked
func (mmUpdate *mModelServiceInterfaceMockUpdate) Times(n uint64) *mModelServiceInterfaceMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of ModelServiceInterfaceMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mModelServiceInterfaceMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_service.ModelServiceInterface
func (mmUpdate *ModelServiceInterfaceMock) Update(ctx context.Context, model *dto.Model) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, model)
	}

	mm_params := ModelServiceInterfaceMockUpdateParams{ctx, model}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := ModelServiceInterfaceMockUpdateParams{ctx, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("ModelServiceInterfaceMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmUpdate.t.Errorf("ModelServiceInterfaceMock.Update got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("ModelServiceInterfaceMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the ModelServiceInterfaceMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, model)
	}
	mmUpdate.t.Fatalf("Unexpected call to ModelServiceInterfaceMock.Update. %v %v", ctx, model)
	return
}

// UpdateAfterCounter returns a count of finished ModelServiceInterfaceMock.Update invocations
func (mmUpdate *ModelServiceInterfaceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of ModelServiceInterfaceMock.Update invocations
func (mmUpdate *ModelServiceInterfaceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to ModelServiceInterfaceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mModelServiceInterfaceMockUpdate) Calls() []*ModelServiceInterfaceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*ModelServiceInterfaceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *ModelServiceInterfaceMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *ModelServiceInterfaceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelServiceInterfaceMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to ModelServiceInterfaceMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelServiceInterfaceMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ModelServiceInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetAllInspect()

			m.MinimockGetByIDInspect()

			m.MinimockRestoreInspect()

			m.MinimockSoftDeleteInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ModelServiceInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ModelServiceInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockRestoreDone() &&
		m.MinimockSoftDeleteDone() &&
		m.MinimockUpdateDone()
}
