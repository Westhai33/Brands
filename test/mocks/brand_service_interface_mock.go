// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i Brands/internal/service.BrandServiceInterface -o brand_service_interface_mock_test.go -n BrandServiceInterfaceMock -p mocks

import (
	"Brands/internal/dto"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// BrandServiceInterfaceMock implements mm_service.BrandServiceInterface
type BrandServiceInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, brand *dto.Brand) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, brand *dto.Brand)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mBrandServiceInterfaceMockCreate

	funcGetAll          func(ctx context.Context, filter string, sort string) (ba1 []dto.Brand, err error)
	funcGetAllOrigin    string
	inspectFuncGetAll   func(ctx context.Context, filter string, sort string)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mBrandServiceInterfaceMockGetAll

	funcGetByID          func(ctx context.Context, id int64) (bp1 *dto.Brand, err error)
	funcGetByIDOrigin    string
	inspectFuncGetByID   func(ctx context.Context, id int64)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mBrandServiceInterfaceMockGetByID

	funcRestore          func(ctx context.Context, id int64) (err error)
	funcRestoreOrigin    string
	inspectFuncRestore   func(ctx context.Context, id int64)
	afterRestoreCounter  uint64
	beforeRestoreCounter uint64
	RestoreMock          mBrandServiceInterfaceMockRestore

	funcSoftDelete          func(ctx context.Context, id int64) (err error)
	funcSoftDeleteOrigin    string
	inspectFuncSoftDelete   func(ctx context.Context, id int64)
	afterSoftDeleteCounter  uint64
	beforeSoftDeleteCounter uint64
	SoftDeleteMock          mBrandServiceInterfaceMockSoftDelete

	funcUpdate          func(ctx context.Context, brand *dto.Brand) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, brand *dto.Brand)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mBrandServiceInterfaceMockUpdate
}

// NewBrandServiceInterfaceMock returns a mock for mm_service.BrandServiceInterface
func NewBrandServiceInterfaceMock(t minimock.Tester) *BrandServiceInterfaceMock {
	m := &BrandServiceInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mBrandServiceInterfaceMockCreate{mock: m}
	m.CreateMock.callArgs = []*BrandServiceInterfaceMockCreateParams{}

	m.GetAllMock = mBrandServiceInterfaceMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*BrandServiceInterfaceMockGetAllParams{}

	m.GetByIDMock = mBrandServiceInterfaceMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*BrandServiceInterfaceMockGetByIDParams{}

	m.RestoreMock = mBrandServiceInterfaceMockRestore{mock: m}
	m.RestoreMock.callArgs = []*BrandServiceInterfaceMockRestoreParams{}

	m.SoftDeleteMock = mBrandServiceInterfaceMockSoftDelete{mock: m}
	m.SoftDeleteMock.callArgs = []*BrandServiceInterfaceMockSoftDeleteParams{}

	m.UpdateMock = mBrandServiceInterfaceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*BrandServiceInterfaceMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBrandServiceInterfaceMockCreate struct {
	optional           bool
	mock               *BrandServiceInterfaceMock
	defaultExpectation *BrandServiceInterfaceMockCreateExpectation
	expectations       []*BrandServiceInterfaceMockCreateExpectation

	callArgs []*BrandServiceInterfaceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BrandServiceInterfaceMockCreateExpectation specifies expectation struct of the BrandServiceInterface.Create
type BrandServiceInterfaceMockCreateExpectation struct {
	mock               *BrandServiceInterfaceMock
	params             *BrandServiceInterfaceMockCreateParams
	paramPtrs          *BrandServiceInterfaceMockCreateParamPtrs
	expectationOrigins BrandServiceInterfaceMockCreateExpectationOrigins
	results            *BrandServiceInterfaceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// BrandServiceInterfaceMockCreateParams contains parameters of the BrandServiceInterface.Create
type BrandServiceInterfaceMockCreateParams struct {
	ctx   context.Context
	brand *dto.Brand
}

// BrandServiceInterfaceMockCreateParamPtrs contains pointers to parameters of the BrandServiceInterface.Create
type BrandServiceInterfaceMockCreateParamPtrs struct {
	ctx   *context.Context
	brand **dto.Brand
}

// BrandServiceInterfaceMockCreateResults contains results of the BrandServiceInterface.Create
type BrandServiceInterfaceMockCreateResults struct {
	i1  int64
	err error
}

// BrandServiceInterfaceMockCreateOrigins contains origins of expectations of the BrandServiceInterface.Create
type BrandServiceInterfaceMockCreateExpectationOrigins struct {
	origin      string
	originCtx   string
	originBrand string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mBrandServiceInterfaceMockCreate) Optional() *mBrandServiceInterfaceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for BrandServiceInterface.Create
func (mmCreate *mBrandServiceInterfaceMockCreate) Expect(ctx context.Context, brand *dto.Brand) *mBrandServiceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("BrandServiceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &BrandServiceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("BrandServiceInterfaceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &BrandServiceInterfaceMockCreateParams{ctx, brand}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for BrandServiceInterface.Create
func (mmCreate *mBrandServiceInterfaceMockCreate) ExpectCtxParam1(ctx context.Context) *mBrandServiceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("BrandServiceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &BrandServiceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("BrandServiceInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectBrandParam2 sets up expected param brand for BrandServiceInterface.Create
func (mmCreate *mBrandServiceInterfaceMockCreate) ExpectBrandParam2(brand *dto.Brand) *mBrandServiceInterfaceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("BrandServiceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &BrandServiceInterfaceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("BrandServiceInterfaceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.brand = &brand
	mmCreate.defaultExpectation.expectationOrigins.originBrand = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the BrandServiceInterface.Create
func (mmCreate *mBrandServiceInterfaceMockCreate) Inspect(f func(ctx context.Context, brand *dto.Brand)) *mBrandServiceInterfaceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for BrandServiceInterfaceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by BrandServiceInterface.Create
func (mmCreate *mBrandServiceInterfaceMockCreate) Return(i1 int64, err error) *BrandServiceInterfaceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("BrandServiceInterfaceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &BrandServiceInterfaceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &BrandServiceInterfaceMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the BrandServiceInterface.Create method
func (mmCreate *mBrandServiceInterfaceMockCreate) Set(f func(ctx context.Context, brand *dto.Brand) (i1 int64, err error)) *BrandServiceInterfaceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the BrandServiceInterface.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the BrandServiceInterface.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the BrandServiceInterface.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mBrandServiceInterfaceMockCreate) When(ctx context.Context, brand *dto.Brand) *BrandServiceInterfaceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("BrandServiceInterfaceMock.Create mock is already set by Set")
	}

	expectation := &BrandServiceInterfaceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &BrandServiceInterfaceMockCreateParams{ctx, brand},
		expectationOrigins: BrandServiceInterfaceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up BrandServiceInterface.Create return parameters for the expectation previously defined by the When method
func (e *BrandServiceInterfaceMockCreateExpectation) Then(i1 int64, err error) *BrandServiceInterfaceMock {
	e.results = &BrandServiceInterfaceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times BrandServiceInterface.Create should be invoked
func (mmCreate *mBrandServiceInterfaceMockCreate) Times(n uint64) *mBrandServiceInterfaceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of BrandServiceInterfaceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mBrandServiceInterfaceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_service.BrandServiceInterface
func (mmCreate *BrandServiceInterfaceMock) Create(ctx context.Context, brand *dto.Brand) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, brand)
	}

	mm_params := BrandServiceInterfaceMockCreateParams{ctx, brand}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := BrandServiceInterfaceMockCreateParams{ctx, brand}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("BrandServiceInterfaceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.brand != nil && !minimock.Equal(*mm_want_ptrs.brand, mm_got.brand) {
				mmCreate.t.Errorf("BrandServiceInterfaceMock.Create got unexpected parameter brand, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originBrand, *mm_want_ptrs.brand, mm_got.brand, minimock.Diff(*mm_want_ptrs.brand, mm_got.brand))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("BrandServiceInterfaceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the BrandServiceInterfaceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, brand)
	}
	mmCreate.t.Fatalf("Unexpected call to BrandServiceInterfaceMock.Create. %v %v", ctx, brand)
	return
}

// CreateAfterCounter returns a count of finished BrandServiceInterfaceMock.Create invocations
func (mmCreate *BrandServiceInterfaceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of BrandServiceInterfaceMock.Create invocations
func (mmCreate *BrandServiceInterfaceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to BrandServiceInterfaceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mBrandServiceInterfaceMockCreate) Calls() []*BrandServiceInterfaceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*BrandServiceInterfaceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *BrandServiceInterfaceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *BrandServiceInterfaceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to BrandServiceInterfaceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to BrandServiceInterfaceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mBrandServiceInterfaceMockGetAll struct {
	optional           bool
	mock               *BrandServiceInterfaceMock
	defaultExpectation *BrandServiceInterfaceMockGetAllExpectation
	expectations       []*BrandServiceInterfaceMockGetAllExpectation

	callArgs []*BrandServiceInterfaceMockGetAllParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BrandServiceInterfaceMockGetAllExpectation specifies expectation struct of the BrandServiceInterface.GetAll
type BrandServiceInterfaceMockGetAllExpectation struct {
	mock               *BrandServiceInterfaceMock
	params             *BrandServiceInterfaceMockGetAllParams
	paramPtrs          *BrandServiceInterfaceMockGetAllParamPtrs
	expectationOrigins BrandServiceInterfaceMockGetAllExpectationOrigins
	results            *BrandServiceInterfaceMockGetAllResults
	returnOrigin       string
	Counter            uint64
}

// BrandServiceInterfaceMockGetAllParams contains parameters of the BrandServiceInterface.GetAll
type BrandServiceInterfaceMockGetAllParams struct {
	ctx    context.Context
	filter string
	sort   string
}

// BrandServiceInterfaceMockGetAllParamPtrs contains pointers to parameters of the BrandServiceInterface.GetAll
type BrandServiceInterfaceMockGetAllParamPtrs struct {
	ctx    *context.Context
	filter *string
	sort   *string
}

// BrandServiceInterfaceMockGetAllResults contains results of the BrandServiceInterface.GetAll
type BrandServiceInterfaceMockGetAllResults struct {
	ba1 []dto.Brand
	err error
}

// BrandServiceInterfaceMockGetAllOrigins contains origins of expectations of the BrandServiceInterface.GetAll
type BrandServiceInterfaceMockGetAllExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
	originSort   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAll *mBrandServiceInterfaceMockGetAll) Optional() *mBrandServiceInterfaceMockGetAll {
	mmGetAll.optional = true
	return mmGetAll
}

// Expect sets up expected params for BrandServiceInterface.GetAll
func (mmGetAll *mBrandServiceInterfaceMockGetAll) Expect(ctx context.Context, filter string, sort string) *mBrandServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &BrandServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.paramPtrs != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by ExpectParams functions")
	}

	mmGetAll.defaultExpectation.params = &BrandServiceInterfaceMockGetAllParams{ctx, filter, sort}
	mmGetAll.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// ExpectCtxParam1 sets up expected param ctx for BrandServiceInterface.GetAll
func (mmGetAll *mBrandServiceInterfaceMockGetAll) ExpectCtxParam1(ctx context.Context) *mBrandServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &BrandServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAll.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAll
}

// ExpectFilterParam2 sets up expected param filter for BrandServiceInterface.GetAll
func (mmGetAll *mBrandServiceInterfaceMockGetAll) ExpectFilterParam2(filter string) *mBrandServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &BrandServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.filter = &filter
	mmGetAll.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGetAll
}

// ExpectSortParam3 sets up expected param sort for BrandServiceInterface.GetAll
func (mmGetAll *mBrandServiceInterfaceMockGetAll) ExpectSortParam3(sort string) *mBrandServiceInterfaceMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &BrandServiceInterfaceMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.sort = &sort
	mmGetAll.defaultExpectation.expectationOrigins.originSort = minimock.CallerInfo(1)

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the BrandServiceInterface.GetAll
func (mmGetAll *mBrandServiceInterfaceMockGetAll) Inspect(f func(ctx context.Context, filter string, sort string)) *mBrandServiceInterfaceMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for BrandServiceInterfaceMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by BrandServiceInterface.GetAll
func (mmGetAll *mBrandServiceInterfaceMockGetAll) Return(ba1 []dto.Brand, err error) *BrandServiceInterfaceMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &BrandServiceInterfaceMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &BrandServiceInterfaceMockGetAllResults{ba1, err}
	mmGetAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// Set uses given function f to mock the BrandServiceInterface.GetAll method
func (mmGetAll *mBrandServiceInterfaceMockGetAll) Set(f func(ctx context.Context, filter string, sort string) (ba1 []dto.Brand, err error)) *BrandServiceInterfaceMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the BrandServiceInterface.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the BrandServiceInterface.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	mmGetAll.mock.funcGetAllOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// When sets expectation for the BrandServiceInterface.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mBrandServiceInterfaceMockGetAll) When(ctx context.Context, filter string, sort string) *BrandServiceInterfaceMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("BrandServiceInterfaceMock.GetAll mock is already set by Set")
	}

	expectation := &BrandServiceInterfaceMockGetAllExpectation{
		mock:               mmGetAll.mock,
		params:             &BrandServiceInterfaceMockGetAllParams{ctx, filter, sort},
		expectationOrigins: BrandServiceInterfaceMockGetAllExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up BrandServiceInterface.GetAll return parameters for the expectation previously defined by the When method
func (e *BrandServiceInterfaceMockGetAllExpectation) Then(ba1 []dto.Brand, err error) *BrandServiceInterfaceMock {
	e.results = &BrandServiceInterfaceMockGetAllResults{ba1, err}
	return e.mock
}

// Times sets number of times BrandServiceInterface.GetAll should be invoked
func (mmGetAll *mBrandServiceInterfaceMockGetAll) Times(n uint64) *mBrandServiceInterfaceMockGetAll {
	if n == 0 {
		mmGetAll.mock.t.Fatalf("Times of BrandServiceInterfaceMock.GetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAll.expectedInvocations, n)
	mmGetAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAll
}

func (mmGetAll *mBrandServiceInterfaceMockGetAll) invocationsDone() bool {
	if len(mmGetAll.expectations) == 0 && mmGetAll.defaultExpectation == nil && mmGetAll.mock.funcGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAll.mock.afterGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAll implements mm_service.BrandServiceInterface
func (mmGetAll *BrandServiceInterfaceMock) GetAll(ctx context.Context, filter string, sort string) (ba1 []dto.Brand, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	mmGetAll.t.Helper()

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, filter, sort)
	}

	mm_params := BrandServiceInterfaceMockGetAllParams{ctx, filter, sort}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, &mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_want_ptrs := mmGetAll.GetAllMock.defaultExpectation.paramPtrs

		mm_got := BrandServiceInterfaceMockGetAllParams{ctx, filter, sort}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAll.t.Errorf("BrandServiceInterfaceMock.GetAll got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGetAll.t.Errorf("BrandServiceInterfaceMock.GetAll got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.sort != nil && !minimock.Equal(*mm_want_ptrs.sort, mm_got.sort) {
				mmGetAll.t.Errorf("BrandServiceInterfaceMock.GetAll got unexpected parameter sort, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originSort, *mm_want_ptrs.sort, mm_got.sort, minimock.Diff(*mm_want_ptrs.sort, mm_got.sort))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("BrandServiceInterfaceMock.GetAll got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the BrandServiceInterfaceMock.GetAll")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, filter, sort)
	}
	mmGetAll.t.Fatalf("Unexpected call to BrandServiceInterfaceMock.GetAll. %v %v %v", ctx, filter, sort)
	return
}

// GetAllAfterCounter returns a count of finished BrandServiceInterfaceMock.GetAll invocations
func (mmGetAll *BrandServiceInterfaceMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of BrandServiceInterfaceMock.GetAll invocations
func (mmGetAll *BrandServiceInterfaceMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to BrandServiceInterfaceMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mBrandServiceInterfaceMockGetAll) Calls() []*BrandServiceInterfaceMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*BrandServiceInterfaceMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *BrandServiceInterfaceMock) MinimockGetAllDone() bool {
	if m.GetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllMock.invocationsDone()
}

// MinimockGetAllInspect logs each unmet expectation
func (m *BrandServiceInterfaceMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.GetAll at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllCounter := mm_atomic.LoadUint64(&m.afterGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && afterGetAllCounter < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.GetAll at\n%s", m.GetAllMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.GetAll at\n%s with params: %#v", m.GetAllMock.defaultExpectation.expectationOrigins.origin, *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && afterGetAllCounter < 1 {
		m.t.Errorf("Expected call to BrandServiceInterfaceMock.GetAll at\n%s", m.funcGetAllOrigin)
	}

	if !m.GetAllMock.invocationsDone() && afterGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to BrandServiceInterfaceMock.GetAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllMock.expectedInvocations), m.GetAllMock.expectedInvocationsOrigin, afterGetAllCounter)
	}
}

type mBrandServiceInterfaceMockGetByID struct {
	optional           bool
	mock               *BrandServiceInterfaceMock
	defaultExpectation *BrandServiceInterfaceMockGetByIDExpectation
	expectations       []*BrandServiceInterfaceMockGetByIDExpectation

	callArgs []*BrandServiceInterfaceMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BrandServiceInterfaceMockGetByIDExpectation specifies expectation struct of the BrandServiceInterface.GetByID
type BrandServiceInterfaceMockGetByIDExpectation struct {
	mock               *BrandServiceInterfaceMock
	params             *BrandServiceInterfaceMockGetByIDParams
	paramPtrs          *BrandServiceInterfaceMockGetByIDParamPtrs
	expectationOrigins BrandServiceInterfaceMockGetByIDExpectationOrigins
	results            *BrandServiceInterfaceMockGetByIDResults
	returnOrigin       string
	Counter            uint64
}

// BrandServiceInterfaceMockGetByIDParams contains parameters of the BrandServiceInterface.GetByID
type BrandServiceInterfaceMockGetByIDParams struct {
	ctx context.Context
	id  int64
}

// BrandServiceInterfaceMockGetByIDParamPtrs contains pointers to parameters of the BrandServiceInterface.GetByID
type BrandServiceInterfaceMockGetByIDParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// BrandServiceInterfaceMockGetByIDResults contains results of the BrandServiceInterface.GetByID
type BrandServiceInterfaceMockGetByIDResults struct {
	bp1 *dto.Brand
	err error
}

// BrandServiceInterfaceMockGetByIDOrigins contains origins of expectations of the BrandServiceInterface.GetByID
type BrandServiceInterfaceMockGetByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mBrandServiceInterfaceMockGetByID) Optional() *mBrandServiceInterfaceMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for BrandServiceInterface.GetByID
func (mmGetByID *mBrandServiceInterfaceMockGetByID) Expect(ctx context.Context, id int64) *mBrandServiceInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("BrandServiceInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &BrandServiceInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("BrandServiceInterfaceMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &BrandServiceInterfaceMockGetByIDParams{ctx, id}
	mmGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for BrandServiceInterface.GetByID
func (mmGetByID *mBrandServiceInterfaceMockGetByID) ExpectCtxParam1(ctx context.Context) *mBrandServiceInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("BrandServiceInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &BrandServiceInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("BrandServiceInterfaceMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByID
}

// ExpectIdParam2 sets up expected param id for BrandServiceInterface.GetByID
func (mmGetByID *mBrandServiceInterfaceMockGetByID) ExpectIdParam2(id int64) *mBrandServiceInterfaceMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("BrandServiceInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &BrandServiceInterfaceMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("BrandServiceInterfaceMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.id = &id
	mmGetByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the BrandServiceInterface.GetByID
func (mmGetByID *mBrandServiceInterfaceMockGetByID) Inspect(f func(ctx context.Context, id int64)) *mBrandServiceInterfaceMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for BrandServiceInterfaceMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by BrandServiceInterface.GetByID
func (mmGetByID *mBrandServiceInterfaceMockGetByID) Return(bp1 *dto.Brand, err error) *BrandServiceInterfaceMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("BrandServiceInterfaceMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &BrandServiceInterfaceMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &BrandServiceInterfaceMockGetByIDResults{bp1, err}
	mmGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// Set uses given function f to mock the BrandServiceInterface.GetByID method
func (mmGetByID *mBrandServiceInterfaceMockGetByID) Set(f func(ctx context.Context, id int64) (bp1 *dto.Brand, err error)) *BrandServiceInterfaceMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the BrandServiceInterface.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the BrandServiceInterface.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	mmGetByID.mock.funcGetByIDOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// When sets expectation for the BrandServiceInterface.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mBrandServiceInterfaceMockGetByID) When(ctx context.Context, id int64) *BrandServiceInterfaceMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("BrandServiceInterfaceMock.GetByID mock is already set by Set")
	}

	expectation := &BrandServiceInterfaceMockGetByIDExpectation{
		mock:               mmGetByID.mock,
		params:             &BrandServiceInterfaceMockGetByIDParams{ctx, id},
		expectationOrigins: BrandServiceInterfaceMockGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up BrandServiceInterface.GetByID return parameters for the expectation previously defined by the When method
func (e *BrandServiceInterfaceMockGetByIDExpectation) Then(bp1 *dto.Brand, err error) *BrandServiceInterfaceMock {
	e.results = &BrandServiceInterfaceMockGetByIDResults{bp1, err}
	return e.mock
}

// Times sets number of times BrandServiceInterface.GetByID should be invoked
func (mmGetByID *mBrandServiceInterfaceMockGetByID) Times(n uint64) *mBrandServiceInterfaceMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of BrandServiceInterfaceMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	mmGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByID
}

func (mmGetByID *mBrandServiceInterfaceMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements mm_service.BrandServiceInterface
func (mmGetByID *BrandServiceInterfaceMock) GetByID(ctx context.Context, id int64) (bp1 *dto.Brand, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	mmGetByID.t.Helper()

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, id)
	}

	mm_params := BrandServiceInterfaceMockGetByIDParams{ctx, id}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := BrandServiceInterfaceMockGetByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("BrandServiceInterfaceMock.GetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetByID.t.Errorf("BrandServiceInterfaceMock.GetByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("BrandServiceInterfaceMock.GetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the BrandServiceInterfaceMock.GetByID")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, id)
	}
	mmGetByID.t.Fatalf("Unexpected call to BrandServiceInterfaceMock.GetByID. %v %v", ctx, id)
	return
}

// GetByIDAfterCounter returns a count of finished BrandServiceInterfaceMock.GetByID invocations
func (mmGetByID *BrandServiceInterfaceMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of BrandServiceInterfaceMock.GetByID invocations
func (mmGetByID *BrandServiceInterfaceMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to BrandServiceInterfaceMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mBrandServiceInterfaceMockGetByID) Calls() []*BrandServiceInterfaceMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*BrandServiceInterfaceMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *BrandServiceInterfaceMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *BrandServiceInterfaceMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.GetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.GetByID at\n%s", m.GetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.GetByID at\n%s with params: %#v", m.GetByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Errorf("Expected call to BrandServiceInterfaceMock.GetByID at\n%s", m.funcGetByIDOrigin)
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to BrandServiceInterfaceMock.GetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), m.GetByIDMock.expectedInvocationsOrigin, afterGetByIDCounter)
	}
}

type mBrandServiceInterfaceMockRestore struct {
	optional           bool
	mock               *BrandServiceInterfaceMock
	defaultExpectation *BrandServiceInterfaceMockRestoreExpectation
	expectations       []*BrandServiceInterfaceMockRestoreExpectation

	callArgs []*BrandServiceInterfaceMockRestoreParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BrandServiceInterfaceMockRestoreExpectation specifies expectation struct of the BrandServiceInterface.Restore
type BrandServiceInterfaceMockRestoreExpectation struct {
	mock               *BrandServiceInterfaceMock
	params             *BrandServiceInterfaceMockRestoreParams
	paramPtrs          *BrandServiceInterfaceMockRestoreParamPtrs
	expectationOrigins BrandServiceInterfaceMockRestoreExpectationOrigins
	results            *BrandServiceInterfaceMockRestoreResults
	returnOrigin       string
	Counter            uint64
}

// BrandServiceInterfaceMockRestoreParams contains parameters of the BrandServiceInterface.Restore
type BrandServiceInterfaceMockRestoreParams struct {
	ctx context.Context
	id  int64
}

// BrandServiceInterfaceMockRestoreParamPtrs contains pointers to parameters of the BrandServiceInterface.Restore
type BrandServiceInterfaceMockRestoreParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// BrandServiceInterfaceMockRestoreResults contains results of the BrandServiceInterface.Restore
type BrandServiceInterfaceMockRestoreResults struct {
	err error
}

// BrandServiceInterfaceMockRestoreOrigins contains origins of expectations of the BrandServiceInterface.Restore
type BrandServiceInterfaceMockRestoreExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRestore *mBrandServiceInterfaceMockRestore) Optional() *mBrandServiceInterfaceMockRestore {
	mmRestore.optional = true
	return mmRestore
}

// Expect sets up expected params for BrandServiceInterface.Restore
func (mmRestore *mBrandServiceInterfaceMockRestore) Expect(ctx context.Context, id int64) *mBrandServiceInterfaceMockRestore {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("BrandServiceInterfaceMock.Restore mock is already set by Set")
	}

	if mmRestore.defaultExpectation == nil {
		mmRestore.defaultExpectation = &BrandServiceInterfaceMockRestoreExpectation{}
	}

	if mmRestore.defaultExpectation.paramPtrs != nil {
		mmRestore.mock.t.Fatalf("BrandServiceInterfaceMock.Restore mock is already set by ExpectParams functions")
	}

	mmRestore.defaultExpectation.params = &BrandServiceInterfaceMockRestoreParams{ctx, id}
	mmRestore.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRestore.expectations {
		if minimock.Equal(e.params, mmRestore.defaultExpectation.params) {
			mmRestore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRestore.defaultExpectation.params)
		}
	}

	return mmRestore
}

// ExpectCtxParam1 sets up expected param ctx for BrandServiceInterface.Restore
func (mmRestore *mBrandServiceInterfaceMockRestore) ExpectCtxParam1(ctx context.Context) *mBrandServiceInterfaceMockRestore {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("BrandServiceInterfaceMock.Restore mock is already set by Set")
	}

	if mmRestore.defaultExpectation == nil {
		mmRestore.defaultExpectation = &BrandServiceInterfaceMockRestoreExpectation{}
	}

	if mmRestore.defaultExpectation.params != nil {
		mmRestore.mock.t.Fatalf("BrandServiceInterfaceMock.Restore mock is already set by Expect")
	}

	if mmRestore.defaultExpectation.paramPtrs == nil {
		mmRestore.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockRestoreParamPtrs{}
	}
	mmRestore.defaultExpectation.paramPtrs.ctx = &ctx
	mmRestore.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRestore
}

// ExpectIdParam2 sets up expected param id for BrandServiceInterface.Restore
func (mmRestore *mBrandServiceInterfaceMockRestore) ExpectIdParam2(id int64) *mBrandServiceInterfaceMockRestore {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("BrandServiceInterfaceMock.Restore mock is already set by Set")
	}

	if mmRestore.defaultExpectation == nil {
		mmRestore.defaultExpectation = &BrandServiceInterfaceMockRestoreExpectation{}
	}

	if mmRestore.defaultExpectation.params != nil {
		mmRestore.mock.t.Fatalf("BrandServiceInterfaceMock.Restore mock is already set by Expect")
	}

	if mmRestore.defaultExpectation.paramPtrs == nil {
		mmRestore.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockRestoreParamPtrs{}
	}
	mmRestore.defaultExpectation.paramPtrs.id = &id
	mmRestore.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmRestore
}

// Inspect accepts an inspector function that has same arguments as the BrandServiceInterface.Restore
func (mmRestore *mBrandServiceInterfaceMockRestore) Inspect(f func(ctx context.Context, id int64)) *mBrandServiceInterfaceMockRestore {
	if mmRestore.mock.inspectFuncRestore != nil {
		mmRestore.mock.t.Fatalf("Inspect function is already set for BrandServiceInterfaceMock.Restore")
	}

	mmRestore.mock.inspectFuncRestore = f

	return mmRestore
}

// Return sets up results that will be returned by BrandServiceInterface.Restore
func (mmRestore *mBrandServiceInterfaceMockRestore) Return(err error) *BrandServiceInterfaceMock {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("BrandServiceInterfaceMock.Restore mock is already set by Set")
	}

	if mmRestore.defaultExpectation == nil {
		mmRestore.defaultExpectation = &BrandServiceInterfaceMockRestoreExpectation{mock: mmRestore.mock}
	}
	mmRestore.defaultExpectation.results = &BrandServiceInterfaceMockRestoreResults{err}
	mmRestore.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRestore.mock
}

// Set uses given function f to mock the BrandServiceInterface.Restore method
func (mmRestore *mBrandServiceInterfaceMockRestore) Set(f func(ctx context.Context, id int64) (err error)) *BrandServiceInterfaceMock {
	if mmRestore.defaultExpectation != nil {
		mmRestore.mock.t.Fatalf("Default expectation is already set for the BrandServiceInterface.Restore method")
	}

	if len(mmRestore.expectations) > 0 {
		mmRestore.mock.t.Fatalf("Some expectations are already set for the BrandServiceInterface.Restore method")
	}

	mmRestore.mock.funcRestore = f
	mmRestore.mock.funcRestoreOrigin = minimock.CallerInfo(1)
	return mmRestore.mock
}

// When sets expectation for the BrandServiceInterface.Restore which will trigger the result defined by the following
// Then helper
func (mmRestore *mBrandServiceInterfaceMockRestore) When(ctx context.Context, id int64) *BrandServiceInterfaceMockRestoreExpectation {
	if mmRestore.mock.funcRestore != nil {
		mmRestore.mock.t.Fatalf("BrandServiceInterfaceMock.Restore mock is already set by Set")
	}

	expectation := &BrandServiceInterfaceMockRestoreExpectation{
		mock:               mmRestore.mock,
		params:             &BrandServiceInterfaceMockRestoreParams{ctx, id},
		expectationOrigins: BrandServiceInterfaceMockRestoreExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRestore.expectations = append(mmRestore.expectations, expectation)
	return expectation
}

// Then sets up BrandServiceInterface.Restore return parameters for the expectation previously defined by the When method
func (e *BrandServiceInterfaceMockRestoreExpectation) Then(err error) *BrandServiceInterfaceMock {
	e.results = &BrandServiceInterfaceMockRestoreResults{err}
	return e.mock
}

// Times sets number of times BrandServiceInterface.Restore should be invoked
func (mmRestore *mBrandServiceInterfaceMockRestore) Times(n uint64) *mBrandServiceInterfaceMockRestore {
	if n == 0 {
		mmRestore.mock.t.Fatalf("Times of BrandServiceInterfaceMock.Restore mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRestore.expectedInvocations, n)
	mmRestore.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRestore
}

func (mmRestore *mBrandServiceInterfaceMockRestore) invocationsDone() bool {
	if len(mmRestore.expectations) == 0 && mmRestore.defaultExpectation == nil && mmRestore.mock.funcRestore == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRestore.mock.afterRestoreCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRestore.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Restore implements mm_service.BrandServiceInterface
func (mmRestore *BrandServiceInterfaceMock) Restore(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmRestore.beforeRestoreCounter, 1)
	defer mm_atomic.AddUint64(&mmRestore.afterRestoreCounter, 1)

	mmRestore.t.Helper()

	if mmRestore.inspectFuncRestore != nil {
		mmRestore.inspectFuncRestore(ctx, id)
	}

	mm_params := BrandServiceInterfaceMockRestoreParams{ctx, id}

	// Record call args
	mmRestore.RestoreMock.mutex.Lock()
	mmRestore.RestoreMock.callArgs = append(mmRestore.RestoreMock.callArgs, &mm_params)
	mmRestore.RestoreMock.mutex.Unlock()

	for _, e := range mmRestore.RestoreMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRestore.RestoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRestore.RestoreMock.defaultExpectation.Counter, 1)
		mm_want := mmRestore.RestoreMock.defaultExpectation.params
		mm_want_ptrs := mmRestore.RestoreMock.defaultExpectation.paramPtrs

		mm_got := BrandServiceInterfaceMockRestoreParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRestore.t.Errorf("BrandServiceInterfaceMock.Restore got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRestore.RestoreMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmRestore.t.Errorf("BrandServiceInterfaceMock.Restore got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRestore.RestoreMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRestore.t.Errorf("BrandServiceInterfaceMock.Restore got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRestore.RestoreMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRestore.RestoreMock.defaultExpectation.results
		if mm_results == nil {
			mmRestore.t.Fatal("No results are set for the BrandServiceInterfaceMock.Restore")
		}
		return (*mm_results).err
	}
	if mmRestore.funcRestore != nil {
		return mmRestore.funcRestore(ctx, id)
	}
	mmRestore.t.Fatalf("Unexpected call to BrandServiceInterfaceMock.Restore. %v %v", ctx, id)
	return
}

// RestoreAfterCounter returns a count of finished BrandServiceInterfaceMock.Restore invocations
func (mmRestore *BrandServiceInterfaceMock) RestoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestore.afterRestoreCounter)
}

// RestoreBeforeCounter returns a count of BrandServiceInterfaceMock.Restore invocations
func (mmRestore *BrandServiceInterfaceMock) RestoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestore.beforeRestoreCounter)
}

// Calls returns a list of arguments used in each call to BrandServiceInterfaceMock.Restore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRestore *mBrandServiceInterfaceMockRestore) Calls() []*BrandServiceInterfaceMockRestoreParams {
	mmRestore.mutex.RLock()

	argCopy := make([]*BrandServiceInterfaceMockRestoreParams, len(mmRestore.callArgs))
	copy(argCopy, mmRestore.callArgs)

	mmRestore.mutex.RUnlock()

	return argCopy
}

// MinimockRestoreDone returns true if the count of the Restore invocations corresponds
// the number of defined expectations
func (m *BrandServiceInterfaceMock) MinimockRestoreDone() bool {
	if m.RestoreMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RestoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RestoreMock.invocationsDone()
}

// MinimockRestoreInspect logs each unmet expectation
func (m *BrandServiceInterfaceMock) MinimockRestoreInspect() {
	for _, e := range m.RestoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Restore at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRestoreCounter := mm_atomic.LoadUint64(&m.afterRestoreCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RestoreMock.defaultExpectation != nil && afterRestoreCounter < 1 {
		if m.RestoreMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Restore at\n%s", m.RestoreMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Restore at\n%s with params: %#v", m.RestoreMock.defaultExpectation.expectationOrigins.origin, *m.RestoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRestore != nil && afterRestoreCounter < 1 {
		m.t.Errorf("Expected call to BrandServiceInterfaceMock.Restore at\n%s", m.funcRestoreOrigin)
	}

	if !m.RestoreMock.invocationsDone() && afterRestoreCounter > 0 {
		m.t.Errorf("Expected %d calls to BrandServiceInterfaceMock.Restore at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RestoreMock.expectedInvocations), m.RestoreMock.expectedInvocationsOrigin, afterRestoreCounter)
	}
}

type mBrandServiceInterfaceMockSoftDelete struct {
	optional           bool
	mock               *BrandServiceInterfaceMock
	defaultExpectation *BrandServiceInterfaceMockSoftDeleteExpectation
	expectations       []*BrandServiceInterfaceMockSoftDeleteExpectation

	callArgs []*BrandServiceInterfaceMockSoftDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BrandServiceInterfaceMockSoftDeleteExpectation specifies expectation struct of the BrandServiceInterface.SoftDelete
type BrandServiceInterfaceMockSoftDeleteExpectation struct {
	mock               *BrandServiceInterfaceMock
	params             *BrandServiceInterfaceMockSoftDeleteParams
	paramPtrs          *BrandServiceInterfaceMockSoftDeleteParamPtrs
	expectationOrigins BrandServiceInterfaceMockSoftDeleteExpectationOrigins
	results            *BrandServiceInterfaceMockSoftDeleteResults
	returnOrigin       string
	Counter            uint64
}

// BrandServiceInterfaceMockSoftDeleteParams contains parameters of the BrandServiceInterface.SoftDelete
type BrandServiceInterfaceMockSoftDeleteParams struct {
	ctx context.Context
	id  int64
}

// BrandServiceInterfaceMockSoftDeleteParamPtrs contains pointers to parameters of the BrandServiceInterface.SoftDelete
type BrandServiceInterfaceMockSoftDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// BrandServiceInterfaceMockSoftDeleteResults contains results of the BrandServiceInterface.SoftDelete
type BrandServiceInterfaceMockSoftDeleteResults struct {
	err error
}

// BrandServiceInterfaceMockSoftDeleteOrigins contains origins of expectations of the BrandServiceInterface.SoftDelete
type BrandServiceInterfaceMockSoftDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) Optional() *mBrandServiceInterfaceMockSoftDelete {
	mmSoftDelete.optional = true
	return mmSoftDelete
}

// Expect sets up expected params for BrandServiceInterface.SoftDelete
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) Expect(ctx context.Context, id int64) *mBrandServiceInterfaceMockSoftDelete {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("BrandServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &BrandServiceInterfaceMockSoftDeleteExpectation{}
	}

	if mmSoftDelete.defaultExpectation.paramPtrs != nil {
		mmSoftDelete.mock.t.Fatalf("BrandServiceInterfaceMock.SoftDelete mock is already set by ExpectParams functions")
	}

	mmSoftDelete.defaultExpectation.params = &BrandServiceInterfaceMockSoftDeleteParams{ctx, id}
	mmSoftDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSoftDelete.expectations {
		if minimock.Equal(e.params, mmSoftDelete.defaultExpectation.params) {
			mmSoftDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSoftDelete.defaultExpectation.params)
		}
	}

	return mmSoftDelete
}

// ExpectCtxParam1 sets up expected param ctx for BrandServiceInterface.SoftDelete
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) ExpectCtxParam1(ctx context.Context) *mBrandServiceInterfaceMockSoftDelete {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("BrandServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &BrandServiceInterfaceMockSoftDeleteExpectation{}
	}

	if mmSoftDelete.defaultExpectation.params != nil {
		mmSoftDelete.mock.t.Fatalf("BrandServiceInterfaceMock.SoftDelete mock is already set by Expect")
	}

	if mmSoftDelete.defaultExpectation.paramPtrs == nil {
		mmSoftDelete.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockSoftDeleteParamPtrs{}
	}
	mmSoftDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmSoftDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSoftDelete
}

// ExpectIdParam2 sets up expected param id for BrandServiceInterface.SoftDelete
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) ExpectIdParam2(id int64) *mBrandServiceInterfaceMockSoftDelete {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("BrandServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &BrandServiceInterfaceMockSoftDeleteExpectation{}
	}

	if mmSoftDelete.defaultExpectation.params != nil {
		mmSoftDelete.mock.t.Fatalf("BrandServiceInterfaceMock.SoftDelete mock is already set by Expect")
	}

	if mmSoftDelete.defaultExpectation.paramPtrs == nil {
		mmSoftDelete.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockSoftDeleteParamPtrs{}
	}
	mmSoftDelete.defaultExpectation.paramPtrs.id = &id
	mmSoftDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmSoftDelete
}

// Inspect accepts an inspector function that has same arguments as the BrandServiceInterface.SoftDelete
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) Inspect(f func(ctx context.Context, id int64)) *mBrandServiceInterfaceMockSoftDelete {
	if mmSoftDelete.mock.inspectFuncSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("Inspect function is already set for BrandServiceInterfaceMock.SoftDelete")
	}

	mmSoftDelete.mock.inspectFuncSoftDelete = f

	return mmSoftDelete
}

// Return sets up results that will be returned by BrandServiceInterface.SoftDelete
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) Return(err error) *BrandServiceInterfaceMock {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("BrandServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	if mmSoftDelete.defaultExpectation == nil {
		mmSoftDelete.defaultExpectation = &BrandServiceInterfaceMockSoftDeleteExpectation{mock: mmSoftDelete.mock}
	}
	mmSoftDelete.defaultExpectation.results = &BrandServiceInterfaceMockSoftDeleteResults{err}
	mmSoftDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSoftDelete.mock
}

// Set uses given function f to mock the BrandServiceInterface.SoftDelete method
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) Set(f func(ctx context.Context, id int64) (err error)) *BrandServiceInterfaceMock {
	if mmSoftDelete.defaultExpectation != nil {
		mmSoftDelete.mock.t.Fatalf("Default expectation is already set for the BrandServiceInterface.SoftDelete method")
	}

	if len(mmSoftDelete.expectations) > 0 {
		mmSoftDelete.mock.t.Fatalf("Some expectations are already set for the BrandServiceInterface.SoftDelete method")
	}

	mmSoftDelete.mock.funcSoftDelete = f
	mmSoftDelete.mock.funcSoftDeleteOrigin = minimock.CallerInfo(1)
	return mmSoftDelete.mock
}

// When sets expectation for the BrandServiceInterface.SoftDelete which will trigger the result defined by the following
// Then helper
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) When(ctx context.Context, id int64) *BrandServiceInterfaceMockSoftDeleteExpectation {
	if mmSoftDelete.mock.funcSoftDelete != nil {
		mmSoftDelete.mock.t.Fatalf("BrandServiceInterfaceMock.SoftDelete mock is already set by Set")
	}

	expectation := &BrandServiceInterfaceMockSoftDeleteExpectation{
		mock:               mmSoftDelete.mock,
		params:             &BrandServiceInterfaceMockSoftDeleteParams{ctx, id},
		expectationOrigins: BrandServiceInterfaceMockSoftDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSoftDelete.expectations = append(mmSoftDelete.expectations, expectation)
	return expectation
}

// Then sets up BrandServiceInterface.SoftDelete return parameters for the expectation previously defined by the When method
func (e *BrandServiceInterfaceMockSoftDeleteExpectation) Then(err error) *BrandServiceInterfaceMock {
	e.results = &BrandServiceInterfaceMockSoftDeleteResults{err}
	return e.mock
}

// Times sets number of times BrandServiceInterface.SoftDelete should be invoked
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) Times(n uint64) *mBrandServiceInterfaceMockSoftDelete {
	if n == 0 {
		mmSoftDelete.mock.t.Fatalf("Times of BrandServiceInterfaceMock.SoftDelete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSoftDelete.expectedInvocations, n)
	mmSoftDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSoftDelete
}

func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) invocationsDone() bool {
	if len(mmSoftDelete.expectations) == 0 && mmSoftDelete.defaultExpectation == nil && mmSoftDelete.mock.funcSoftDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSoftDelete.mock.afterSoftDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSoftDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SoftDelete implements mm_service.BrandServiceInterface
func (mmSoftDelete *BrandServiceInterfaceMock) SoftDelete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmSoftDelete.beforeSoftDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmSoftDelete.afterSoftDeleteCounter, 1)

	mmSoftDelete.t.Helper()

	if mmSoftDelete.inspectFuncSoftDelete != nil {
		mmSoftDelete.inspectFuncSoftDelete(ctx, id)
	}

	mm_params := BrandServiceInterfaceMockSoftDeleteParams{ctx, id}

	// Record call args
	mmSoftDelete.SoftDeleteMock.mutex.Lock()
	mmSoftDelete.SoftDeleteMock.callArgs = append(mmSoftDelete.SoftDeleteMock.callArgs, &mm_params)
	mmSoftDelete.SoftDeleteMock.mutex.Unlock()

	for _, e := range mmSoftDelete.SoftDeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSoftDelete.SoftDeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSoftDelete.SoftDeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmSoftDelete.SoftDeleteMock.defaultExpectation.params
		mm_want_ptrs := mmSoftDelete.SoftDeleteMock.defaultExpectation.paramPtrs

		mm_got := BrandServiceInterfaceMockSoftDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSoftDelete.t.Errorf("BrandServiceInterfaceMock.SoftDelete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSoftDelete.SoftDeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmSoftDelete.t.Errorf("BrandServiceInterfaceMock.SoftDelete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSoftDelete.SoftDeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSoftDelete.t.Errorf("BrandServiceInterfaceMock.SoftDelete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSoftDelete.SoftDeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSoftDelete.SoftDeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmSoftDelete.t.Fatal("No results are set for the BrandServiceInterfaceMock.SoftDelete")
		}
		return (*mm_results).err
	}
	if mmSoftDelete.funcSoftDelete != nil {
		return mmSoftDelete.funcSoftDelete(ctx, id)
	}
	mmSoftDelete.t.Fatalf("Unexpected call to BrandServiceInterfaceMock.SoftDelete. %v %v", ctx, id)
	return
}

// SoftDeleteAfterCounter returns a count of finished BrandServiceInterfaceMock.SoftDelete invocations
func (mmSoftDelete *BrandServiceInterfaceMock) SoftDeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSoftDelete.afterSoftDeleteCounter)
}

// SoftDeleteBeforeCounter returns a count of BrandServiceInterfaceMock.SoftDelete invocations
func (mmSoftDelete *BrandServiceInterfaceMock) SoftDeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSoftDelete.beforeSoftDeleteCounter)
}

// Calls returns a list of arguments used in each call to BrandServiceInterfaceMock.SoftDelete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSoftDelete *mBrandServiceInterfaceMockSoftDelete) Calls() []*BrandServiceInterfaceMockSoftDeleteParams {
	mmSoftDelete.mutex.RLock()

	argCopy := make([]*BrandServiceInterfaceMockSoftDeleteParams, len(mmSoftDelete.callArgs))
	copy(argCopy, mmSoftDelete.callArgs)

	mmSoftDelete.mutex.RUnlock()

	return argCopy
}

// MinimockSoftDeleteDone returns true if the count of the SoftDelete invocations corresponds
// the number of defined expectations
func (m *BrandServiceInterfaceMock) MinimockSoftDeleteDone() bool {
	if m.SoftDeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SoftDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SoftDeleteMock.invocationsDone()
}

// MinimockSoftDeleteInspect logs each unmet expectation
func (m *BrandServiceInterfaceMock) MinimockSoftDeleteInspect() {
	for _, e := range m.SoftDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.SoftDelete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSoftDeleteCounter := mm_atomic.LoadUint64(&m.afterSoftDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SoftDeleteMock.defaultExpectation != nil && afterSoftDeleteCounter < 1 {
		if m.SoftDeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.SoftDelete at\n%s", m.SoftDeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.SoftDelete at\n%s with params: %#v", m.SoftDeleteMock.defaultExpectation.expectationOrigins.origin, *m.SoftDeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSoftDelete != nil && afterSoftDeleteCounter < 1 {
		m.t.Errorf("Expected call to BrandServiceInterfaceMock.SoftDelete at\n%s", m.funcSoftDeleteOrigin)
	}

	if !m.SoftDeleteMock.invocationsDone() && afterSoftDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to BrandServiceInterfaceMock.SoftDelete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SoftDeleteMock.expectedInvocations), m.SoftDeleteMock.expectedInvocationsOrigin, afterSoftDeleteCounter)
	}
}

type mBrandServiceInterfaceMockUpdate struct {
	optional           bool
	mock               *BrandServiceInterfaceMock
	defaultExpectation *BrandServiceInterfaceMockUpdateExpectation
	expectations       []*BrandServiceInterfaceMockUpdateExpectation

	callArgs []*BrandServiceInterfaceMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BrandServiceInterfaceMockUpdateExpectation specifies expectation struct of the BrandServiceInterface.Update
type BrandServiceInterfaceMockUpdateExpectation struct {
	mock               *BrandServiceInterfaceMock
	params             *BrandServiceInterfaceMockUpdateParams
	paramPtrs          *BrandServiceInterfaceMockUpdateParamPtrs
	expectationOrigins BrandServiceInterfaceMockUpdateExpectationOrigins
	results            *BrandServiceInterfaceMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// BrandServiceInterfaceMockUpdateParams contains parameters of the BrandServiceInterface.Update
type BrandServiceInterfaceMockUpdateParams struct {
	ctx   context.Context
	brand *dto.Brand
}

// BrandServiceInterfaceMockUpdateParamPtrs contains pointers to parameters of the BrandServiceInterface.Update
type BrandServiceInterfaceMockUpdateParamPtrs struct {
	ctx   *context.Context
	brand **dto.Brand
}

// BrandServiceInterfaceMockUpdateResults contains results of the BrandServiceInterface.Update
type BrandServiceInterfaceMockUpdateResults struct {
	err error
}

// BrandServiceInterfaceMockUpdateOrigins contains origins of expectations of the BrandServiceInterface.Update
type BrandServiceInterfaceMockUpdateExpectationOrigins struct {
	origin      string
	originCtx   string
	originBrand string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mBrandServiceInterfaceMockUpdate) Optional() *mBrandServiceInterfaceMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for BrandServiceInterface.Update
func (mmUpdate *mBrandServiceInterfaceMockUpdate) Expect(ctx context.Context, brand *dto.Brand) *mBrandServiceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("BrandServiceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &BrandServiceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("BrandServiceInterfaceMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &BrandServiceInterfaceMockUpdateParams{ctx, brand}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for BrandServiceInterface.Update
func (mmUpdate *mBrandServiceInterfaceMockUpdate) ExpectCtxParam1(ctx context.Context) *mBrandServiceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("BrandServiceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &BrandServiceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("BrandServiceInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectBrandParam2 sets up expected param brand for BrandServiceInterface.Update
func (mmUpdate *mBrandServiceInterfaceMockUpdate) ExpectBrandParam2(brand *dto.Brand) *mBrandServiceInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("BrandServiceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &BrandServiceInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("BrandServiceInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &BrandServiceInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.brand = &brand
	mmUpdate.defaultExpectation.expectationOrigins.originBrand = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the BrandServiceInterface.Update
func (mmUpdate *mBrandServiceInterfaceMockUpdate) Inspect(f func(ctx context.Context, brand *dto.Brand)) *mBrandServiceInterfaceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for BrandServiceInterfaceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by BrandServiceInterface.Update
func (mmUpdate *mBrandServiceInterfaceMockUpdate) Return(err error) *BrandServiceInterfaceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("BrandServiceInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &BrandServiceInterfaceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &BrandServiceInterfaceMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the BrandServiceInterface.Update method
func (mmUpdate *mBrandServiceInterfaceMockUpdate) Set(f func(ctx context.Context, brand *dto.Brand) (err error)) *BrandServiceInterfaceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the BrandServiceInterface.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the BrandServiceInterface.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the BrandServiceInterface.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mBrandServiceInterfaceMockUpdate) When(ctx context.Context, brand *dto.Brand) *BrandServiceInterfaceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("BrandServiceInterfaceMock.Update mock is already set by Set")
	}

	expectation := &BrandServiceInterfaceMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &BrandServiceInterfaceMockUpdateParams{ctx, brand},
		expectationOrigins: BrandServiceInterfaceMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up BrandServiceInterface.Update return parameters for the expectation previously defined by the When method
func (e *BrandServiceInterfaceMockUpdateExpectation) Then(err error) *BrandServiceInterfaceMock {
	e.results = &BrandServiceInterfaceMockUpdateResults{err}
	return e.mock
}

// Times sets number of times BrandServiceInterface.Update should be invoked
func (mmUpdate *mBrandServiceInterfaceMockUpdate) Times(n uint64) *mBrandServiceInterfaceMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of BrandServiceInterfaceMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mBrandServiceInterfaceMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_service.BrandServiceInterface
func (mmUpdate *BrandServiceInterfaceMock) Update(ctx context.Context, brand *dto.Brand) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, brand)
	}

	mm_params := BrandServiceInterfaceMockUpdateParams{ctx, brand}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := BrandServiceInterfaceMockUpdateParams{ctx, brand}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("BrandServiceInterfaceMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.brand != nil && !minimock.Equal(*mm_want_ptrs.brand, mm_got.brand) {
				mmUpdate.t.Errorf("BrandServiceInterfaceMock.Update got unexpected parameter brand, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originBrand, *mm_want_ptrs.brand, mm_got.brand, minimock.Diff(*mm_want_ptrs.brand, mm_got.brand))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("BrandServiceInterfaceMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the BrandServiceInterfaceMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, brand)
	}
	mmUpdate.t.Fatalf("Unexpected call to BrandServiceInterfaceMock.Update. %v %v", ctx, brand)
	return
}

// UpdateAfterCounter returns a count of finished BrandServiceInterfaceMock.Update invocations
func (mmUpdate *BrandServiceInterfaceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of BrandServiceInterfaceMock.Update invocations
func (mmUpdate *BrandServiceInterfaceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to BrandServiceInterfaceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mBrandServiceInterfaceMockUpdate) Calls() []*BrandServiceInterfaceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*BrandServiceInterfaceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *BrandServiceInterfaceMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *BrandServiceInterfaceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BrandServiceInterfaceMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to BrandServiceInterfaceMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to BrandServiceInterfaceMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BrandServiceInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetAllInspect()

			m.MinimockGetByIDInspect()

			m.MinimockRestoreInspect()

			m.MinimockSoftDeleteInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BrandServiceInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BrandServiceInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockRestoreDone() &&
		m.MinimockSoftDeleteDone() &&
		m.MinimockUpdateDone()
}
